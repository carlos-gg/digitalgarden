{"version":3,"file":"unsafe-eval.min.js","sources":["../../src/utils/data/ViewableBuffer.ts","../../src/scene/particle-container/shared/utils/createIndicesForQuads.ts","../../src/scene/particle-container/shared/utils/generateParticleUpdateFunction.ts","../../src/scene/particle-container/shared/ParticleBuffer.ts","../../src/unsafe-eval/particle/particleUpdateFunctions.ts","../../src/unsafe-eval/particle/generateParticleUpdatePolyfill.ts","../../src/unsafe-eval/shader/generateShaderSyncPolyfill.ts","../../src/unsafe-eval/ubo/uboSyncFunctions.ts","../../src/unsafe-eval/ubo/generateUboSyncPolyfill.ts","../../src/unsafe-eval/uniforms/uniformSyncFunctions.ts","../../src/unsafe-eval/uniforms/generateUniformsSyncPolyfill.ts","../../src/unsafe-eval/init.ts"],"sourcesContent":["type TypedArray = Float32Array | Uint32Array | Int32Array | Uint8Array;\n\n/**\n * Flexible wrapper around `ArrayBuffer` that also provides typed array views on demand.\n * @memberof utils\n */\nexport class ViewableBuffer\n{\n    /** The size of the buffer in bytes. */\n    public size: number;\n\n    /** Underlying `ArrayBuffer` that holds all the data and is of capacity `this.size`. */\n    public rawBinaryData: ArrayBuffer;\n\n    /** View on the raw binary data as a `Uint32Array`. */\n    public uint32View: Uint32Array;\n\n    /** View on the raw binary data as a `Float32Array`. */\n    public float32View: Float32Array;\n    public uint16View: Uint16Array;\n\n    private _int8View: Int8Array;\n    private _uint8View: Uint8Array;\n    private _int16View: Int16Array;\n    private _int32View: Int32Array;\n    private _float64Array: Float64Array;\n    private _bigUint64Array: BigUint64Array;\n\n    /**\n     * @param length - The size of the buffer in bytes.\n     */\n    constructor(length: number);\n\n    /**\n     * @param arrayBuffer - The source array buffer.\n     */\n    constructor(arrayBuffer: ArrayBuffer);\n\n    constructor(sizeOrBuffer: number | ArrayBuffer | Uint8Array)\n    {\n        if (typeof sizeOrBuffer === 'number')\n        {\n            this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);\n        }\n        else if (sizeOrBuffer instanceof Uint8Array)\n        {\n            this.rawBinaryData = sizeOrBuffer.buffer;\n        }\n        else\n        {\n            this.rawBinaryData = sizeOrBuffer;\n        }\n\n        this.uint32View = new Uint32Array(this.rawBinaryData);\n        this.float32View = new Float32Array(this.rawBinaryData);\n\n        this.size = this.rawBinaryData.byteLength;\n    }\n\n    /** View on the raw binary data as a `Int8Array`. */\n    get int8View(): Int8Array\n    {\n        if (!this._int8View)\n        {\n            this._int8View = new Int8Array(this.rawBinaryData);\n        }\n\n        return this._int8View;\n    }\n\n    /** View on the raw binary data as a `Uint8Array`. */\n    get uint8View(): Uint8Array\n    {\n        if (!this._uint8View)\n        {\n            this._uint8View = new Uint8Array(this.rawBinaryData);\n        }\n\n        return this._uint8View;\n    }\n\n    /**  View on the raw binary data as a `Int16Array`. */\n    get int16View(): Int16Array\n    {\n        if (!this._int16View)\n        {\n            this._int16View = new Int16Array(this.rawBinaryData);\n        }\n\n        return this._int16View;\n    }\n\n    /** View on the raw binary data as a `Int32Array`. */\n    get int32View(): Int32Array\n    {\n        if (!this._int32View)\n        {\n            this._int32View = new Int32Array(this.rawBinaryData);\n        }\n\n        return this._int32View;\n    }\n\n    /** View on the raw binary data as a `Float64Array`. */\n    get float64View(): Float64Array\n    {\n        if (!this._float64Array)\n        {\n            this._float64Array = new Float64Array(this.rawBinaryData);\n        }\n\n        return this._float64Array;\n    }\n\n    /** View on the raw binary data as a `BigUint64Array`. */\n    get bigUint64View(): BigUint64Array\n    {\n        if (!this._bigUint64Array)\n        {\n            this._bigUint64Array = new BigUint64Array(this.rawBinaryData);\n        }\n\n        return this._bigUint64Array;\n    }\n\n    /**\n     * Returns the view of the given type.\n     * @param type - One of `int8`, `uint8`, `int16`,\n     *    `uint16`, `int32`, `uint32`, and `float32`.\n     * @returns - typed array of given type\n     */\n    public view(type: string): TypedArray\n    {\n        return (this as any)[`${type}View`];\n    }\n\n    /** Destroys all buffer references. Do not use after calling this. */\n    public destroy(): void\n    {\n        this.rawBinaryData = null;\n        this._int8View = null;\n        this._uint8View = null;\n        this._int16View = null;\n        this.uint16View = null;\n        this._int32View = null;\n        this.uint32View = null;\n        this.float32View = null;\n    }\n\n    /**\n     * Returns the size of the given type in bytes.\n     * @param type - One of `int8`, `uint8`, `int16`,\n     *   `uint16`, `int32`, `uint32`, and `float32`.\n     * @returns - size of the type in bytes\n     */\n    public static sizeOf(type: string): number\n    {\n        switch (type)\n        {\n            case 'int8':\n            case 'uint8':\n                return 1;\n            case 'int16':\n            case 'uint16':\n                return 2;\n            case 'int32':\n            case 'uint32':\n            case 'float32':\n                return 4;\n            default:\n                throw new Error(`${type} isn't a valid view type`);\n        }\n    }\n}\n","/**\n * Generic Mask Stack data structure\n * @function createIndicesForQuads\n * @param {number} size - Number of quads\n * @param {Uint16Array|Uint32Array} [outBuffer] - Buffer for output, length has to be `6 * size`\n * @returns {Uint16Array|Uint32Array} - Resulting index buffer\n */\nexport function createIndicesForQuads(\n    size: number,\n    outBuffer: Uint16Array | Uint32Array | null = null\n): Uint16Array | Uint32Array\n{\n    // the total number of indices in our array, there are 6 points per quad.\n    const totalIndices = size * 6;\n\n    // Check if we need to use Uint32Array\n    if (totalIndices > 65535)\n    {\n        outBuffer = outBuffer || new Uint32Array(totalIndices); // Use Uint32Array if needed\n    }\n    else\n    {\n        outBuffer = outBuffer || new Uint16Array(totalIndices);\n    }\n\n    if (outBuffer.length !== totalIndices)\n    {\n        throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);\n    }\n\n    // fill the indices with the quads to draw\n    for (let i = 0, j = 0; i < totalIndices; i += 6, j += 4)\n    {\n        outBuffer[i + 0] = j + 0;\n        outBuffer[i + 1] = j + 1;\n        outBuffer[i + 2] = j + 2;\n        outBuffer[i + 3] = j + 0;\n        outBuffer[i + 4] = j + 2;\n        outBuffer[i + 5] = j + 3;\n    }\n\n    return outBuffer;\n}\n","import {\n    getAttributeInfoFromFormat\n} from '../../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { IParticle } from '../Particle';\nimport type { ParticleRendererProperty } from '../particleData';\n\n// TODO rename to update function\nexport type ParticleUpdateFunction = (ps: IParticle[], f32v: Float32Array, u32v: Uint32Array) => void;\n\nexport function generateParticleUpdateFunction(properties: Record<string, ParticleRendererProperty>)\n{\n    return {\n        dynamicUpdate: generateUpdateFunction(properties, true),\n        staticUpdate: generateUpdateFunction(properties, false),\n    };\n}\n\nfunction generateUpdateFunction(\n    properties: Record<string, ParticleRendererProperty>,\n    dynamic: boolean\n): ParticleUpdateFunction\n{\n    const funcFragments: string[] = [];\n\n    funcFragments.push(`\n      \n        var index = 0;\n\n        for (let i = 0; i < ps.length; ++i)\n        {\n            const p = ps[i];\n\n            `);\n\n    let offset = 0;\n\n    for (const i in properties)\n    {\n        const property = properties[i];\n\n        if (dynamic !== property.dynamic) continue;\n\n        funcFragments.push(`offset = index + ${offset}`);\n\n        funcFragments.push(property.code);\n\n        const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n        offset += attributeInfo.stride / 4;\n    }\n\n    funcFragments.push(`\n            index += stride * 4;\n        }\n    `);\n\n    // add to the front..\n    funcFragments.unshift(`\n        var stride = ${offset};\n    `);\n\n    const functionSource = funcFragments.join('\\n');\n\n    // eslint-disable-next-line no-new-func\n    return new Function('ps', 'f32v', 'u32v', functionSource) as ParticleUpdateFunction;\n}\n","import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport { getAttributeInfoFromFormat } from '../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer';\nimport { createIndicesForQuads } from './utils/createIndicesForQuads';\nimport { generateParticleUpdateFunction } from './utils/generateParticleUpdateFunction';\n\nimport type { IndexBufferArray } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport type { IParticle } from './Particle';\nimport type { ParticleRendererProperty } from './particleData';\nimport type { ParticleUpdateFunction } from './utils/generateParticleUpdateFunction';\n\n/**\n * Options for creating a ParticleBuffer.\n * @property {number} size - The size of the particle buffer.\n * @property {Record<string, ParticleRendererProperty>} properties - A record of attributes that the particle container uses.\n */\nexport interface ParticleBufferOptions\n{\n    size: number;\n    properties: Record<string, ParticleRendererProperty>;\n}\n\n/**\n * The ParticleBuffer holds the buffers and geometry for a particle container.\n * It also contains the upload functions for the static and dynamic properties.\n * @internal\n */\nexport class ParticleBuffer\n{\n    /** The buffer containing static attribute data for all elements in the batch. */\n    public staticAttributeBuffer: ViewableBuffer;\n    /** The buffer containing dynamic attribute data for all elements in the batch. */\n    public dynamicAttributeBuffer: ViewableBuffer;\n\n    private readonly _staticBuffer: Buffer;\n    private readonly _dynamicBuffer: Buffer;\n\n    /** The buffer containing index data for all elements in the batch. */\n    public indexBuffer: IndexBufferArray;\n\n    private readonly _dynamicStride: number;\n    private readonly _staticStride: number;\n\n    /** The geometry of the particle buffer. */\n    public readonly geometry: Geometry;\n\n    private _size = 0;\n    private readonly _dynamicUpload: ParticleUpdateFunction;\n    private readonly _staticUpload: ParticleUpdateFunction;\n    private readonly _generateParticleUpdateCache: Record<string, {\n        dynamicUpdate: ParticleUpdateFunction;\n        staticUpdate: ParticleUpdateFunction;\n    }> = {};\n\n    constructor(options: ParticleBufferOptions)\n    {\n        // size in sprites!\n        const size = this._size = options.size ?? 1000;\n\n        // TODO add the option to specify what is dynamic!\n        const properties = options.properties;\n\n        // in bytes!\n        let staticVertexSize = 0;\n        let dynamicVertexSize = 0;\n\n        for (const i in properties)\n        {\n            const property = properties[i];\n            const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n            if (property.dynamic)\n            {\n                // dynamic.\n                dynamicVertexSize += attributeInfo.stride;\n            }\n            else\n            {\n                // static.\n                staticVertexSize += attributeInfo.stride;\n            }\n        }\n\n        this._dynamicStride = dynamicVertexSize / 4;\n        this._staticStride = staticVertexSize / 4;\n\n        this.staticAttributeBuffer = new ViewableBuffer(size * 4 * staticVertexSize);\n        this.dynamicAttributeBuffer = new ViewableBuffer(size * 4 * dynamicVertexSize);\n\n        this.indexBuffer = createIndicesForQuads(size);\n\n        // build geometry..\n\n        const geometry = new Geometry();\n\n        let dynamicOffset = 0;\n        let staticOffset = 0;\n\n        this._staticBuffer = new Buffer({\n            data: new Float32Array(1),\n            label: 'static-particle-buffer',\n            shrinkToFit: false,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n        });\n\n        this._dynamicBuffer = new Buffer({\n            data: new Float32Array(1),\n            label: 'dynamic-particle-buffer',\n            shrinkToFit: false,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n        });\n\n        for (const i in properties)\n        {\n            const property = properties[i];\n            const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n            if (property.dynamic)\n            {\n                geometry.addAttribute(property.attributeName, {\n                    buffer: this._dynamicBuffer,\n                    stride: this._dynamicStride * 4,\n                    offset: dynamicOffset * 4,\n                    format: property.format,\n                });\n                dynamicOffset += attributeInfo.size;\n            }\n            else\n            {\n                geometry.addAttribute(property.attributeName, {\n                    buffer: this._staticBuffer,\n                    stride: this._staticStride * 4,\n                    offset: staticOffset * 4,\n                    format: property.format,\n                });\n                staticOffset += attributeInfo.size;\n            }\n        }\n\n        geometry.addIndex(this.indexBuffer);\n\n        const uploadFunction = this.getParticleUpdate(properties);\n\n        this._dynamicUpload = uploadFunction.dynamicUpdate;\n        this._staticUpload = uploadFunction.staticUpdate;\n\n        this.geometry = geometry;\n    }\n\n    public getParticleUpdate(properties: Record<string, ParticleRendererProperty>)\n    {\n        const key = getParticleSyncKey(properties);\n\n        if (this._generateParticleUpdateCache[key])\n        {\n            return this._generateParticleUpdateCache[key];\n        }\n\n        this._generateParticleUpdateCache[key] = this.generateParticleUpdate(properties);\n\n        return this._generateParticleUpdateCache[key];\n    }\n\n    public generateParticleUpdate(properties: Record<string, ParticleRendererProperty>)\n    {\n        return generateParticleUpdateFunction(properties);\n    }\n\n    public update(particles: IParticle[], uploadStatic: boolean)\n    {\n        // first resize the buffers if needed!\n        // TODO resize!\n        if (particles.length > this._size)\n        {\n            uploadStatic = true;\n\n            this._size = Math.max(particles.length, (this._size * 1.5) | 0);\n\n            this.staticAttributeBuffer = new ViewableBuffer(this._size * this._staticStride * 4 * 4);\n            this.dynamicAttributeBuffer = new ViewableBuffer(this._size * this._dynamicStride * 4 * 4);\n            this.indexBuffer = createIndicesForQuads(this._size);\n\n            this.geometry.indexBuffer.setDataWithSize(\n                this.indexBuffer, this.indexBuffer.byteLength, true);\n        }\n\n        const dynamicAttributeBuffer = this.dynamicAttributeBuffer;\n\n        this._dynamicUpload(particles, dynamicAttributeBuffer.float32View, dynamicAttributeBuffer.uint32View);\n\n        this._dynamicBuffer.setDataWithSize(\n            this.dynamicAttributeBuffer.float32View, particles.length * this._dynamicStride * 4, true);\n\n        if (uploadStatic)\n        {\n            const staticAttributeBuffer = this.staticAttributeBuffer;\n\n            this._staticUpload(particles, staticAttributeBuffer.float32View, staticAttributeBuffer.uint32View);\n\n            this._staticBuffer.setDataWithSize(\n                staticAttributeBuffer.float32View, particles.length * this._staticStride * 4, true);\n        }\n    }\n\n    public destroy()\n    {\n        this._staticBuffer.destroy();\n        this._dynamicBuffer.destroy();\n        this.geometry.destroy();\n    }\n}\n\nfunction getParticleSyncKey(properties: Record<string, ParticleRendererProperty>)\n{\n    const keyGen: string[] = [];\n\n    for (const key in properties)\n    {\n        const property = properties[key];\n\n        keyGen.push(key, property.code, property.dynamic ? 'd' : 's');\n    }\n\n    return keyGen.join('_');\n}\n\n","import type { IParticle } from '../../scene/particle-container/shared/Particle';\n\nexport const particleUpdateFunctions = {\n    aVertex: (ps: IParticle[], f32v: Float32Array, _u32v: Uint32Array, offset: number, stride: number) =>\n    {\n        let w0 = 0;\n        let w1 = 0;\n        let h0 = 0;\n        let h1 = 0;\n\n        for (let i = 0; i < ps.length; ++i)\n        {\n            const p = ps[i];\n            const texture = p.texture;\n            const sx = p.scaleX;\n            const sy = p.scaleY;\n            const ax = p.anchorX;\n            const ay = p.anchorY;\n\n            const trim = texture.trim;\n            const orig = texture.orig;\n\n            if (trim)\n            {\n                w1 = trim.x - (ax * orig.width);\n                w0 = w1 + trim.width;\n\n                h1 = trim.y - (ay * orig.height);\n                h0 = h1 + trim.height;\n            }\n            else\n            {\n                w0 = (orig.width) * (1 - ax);\n                w1 = (orig.width) * -ax;\n\n                h0 = orig.height * (1 - ay);\n                h1 = orig.height * -ay;\n            }\n\n            f32v[offset] = w1 * sx;\n            f32v[offset + 1] = h1 * sy;\n\n            f32v[offset + stride] = w0 * sx;\n            f32v[offset + stride + 1] = h1 * sy;\n\n            f32v[offset + (stride * 2)] = w0 * sx;\n            f32v[offset + (stride * 2) + 1] = h0 * sy;\n\n            f32v[offset + (stride * 3)] = w1 * sx;\n            f32v[offset + (stride * 3) + 1] = h0 * sy;\n\n            offset += stride * 4;\n        }\n    },\n    aPosition: (ps: IParticle[], f32v: Float32Array, _u32v: Uint32Array, offset: number, stride: number) =>\n    {\n        for (let i = 0; i < ps.length; ++i)\n        {\n            const p = ps[i];\n            const x = p.x;\n            const y = p.y;\n\n            f32v[offset] = x;\n            f32v[offset + 1] = y;\n\n            f32v[offset + stride] = x;\n            f32v[offset + stride + 1] = y;\n\n            f32v[offset + (stride * 2)] = x;\n            f32v[offset + (stride * 2) + 1] = y;\n\n            f32v[offset + (stride * 3)] = x;\n            f32v[offset + (stride * 3) + 1] = y;\n\n            offset += stride * 4;\n        }\n    },\n    aRotation: (ps: IParticle[], f32v: Float32Array, _u32v: Uint32Array, offset: number, stride: number) =>\n    {\n        for (let i = 0; i < ps.length; ++i)\n        {\n            const rotation = ps[i].rotation;\n\n            f32v[offset] = rotation;\n            f32v[offset + stride] = rotation;\n            f32v[offset + (stride * 2)] = rotation;\n            f32v[offset + (stride * 3)] = rotation;\n\n            offset += stride * 4;\n        }\n    },\n    aUV: (ps: IParticle[], f32v: Float32Array, _u32v: Uint32Array, offset: number, stride: number) =>\n    {\n        for (let i = 0; i < ps.length; ++i)\n        {\n            const uvs = ps[i].texture.uvs;\n\n            f32v[offset] = uvs.x0;\n            f32v[offset + 1] = uvs.y0;\n\n            f32v[offset + stride] = uvs.x1;\n            f32v[offset + stride + 1] = uvs.y1;\n\n            f32v[offset + (stride * 2)] = uvs.x2;\n            f32v[offset + (stride * 2) + 1] = uvs.y2;\n\n            f32v[offset + (stride * 3)] = uvs.x3;\n            f32v[offset + (stride * 3) + 1] = uvs.y3;\n\n            offset += stride * 4;\n        }\n    },\n    aColor: (ps: IParticle[], _f32v: Float32Array, u32v: Uint32Array, offset: number, stride: number) =>\n    {\n        for (let i = 0; i < ps.length; ++i)\n        {\n            const c = ps[i].color;\n\n            u32v[offset] = c;\n            u32v[offset + stride] = c;\n            u32v[offset + (stride * 2)] = c;\n            u32v[offset + (stride * 3)] = c;\n\n            offset += stride * 4;\n        }\n    }\n};\n","import { getAttributeInfoFromFormat } from '../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat';\nimport { particleUpdateFunctions } from './particleUpdateFunctions';\n\nimport type { IParticle } from '../../scene/particle-container/shared/Particle';\nimport type { ParticleRendererProperty } from '../../scene/particle-container/shared/particleData';\n\n// eslint-disable-next-line max-len\nexport type ParticleUpdateFunction = (ps: IParticle[], f32v: Float32Array, u32v: Uint32Array, offset: number, stride: number) => void;\n\nexport function generateParticleUpdatePolyfill(properties: ParticleRendererProperty[])\n{\n    const dynamicProperties = properties.filter((p) => p.dynamic);\n    const staticProperties = properties.filter((p) => !p.dynamic);\n\n    return {\n        dynamicUpdate: generateUpdateFunction(dynamicProperties),\n        staticUpdate: generateUpdateFunction(staticProperties),\n    };\n}\n\nfunction generateUpdateFunction(properties: ParticleRendererProperty[]): ParticleUpdateFunction\n{\n    let stride = 0;\n\n    const updateData: { stride: number; updateFunction: ParticleUpdateFunction }[] = [];\n\n    for (let i = 0; i < properties.length; i++)\n    {\n        const property = properties[i];\n\n        const attributeStride = getAttributeInfoFromFormat(property.format).stride / 4;\n\n        stride += attributeStride;\n\n        updateData.push({\n            stride: attributeStride,\n            updateFunction:\n            property.updateFunction\n            || particleUpdateFunctions[property.attributeName as keyof typeof particleUpdateFunctions]\n        });\n    }\n\n    return (ps: IParticle[], f32v: Float32Array, u32v: Uint32Array) =>\n    {\n        let offset = 0;\n\n        for (let i = 0; i < updateData.length; i++)\n        {\n            const obx = updateData[i];\n\n            obx.updateFunction(ps, f32v, u32v, offset, stride);\n            offset += obx.stride;\n        }\n    };\n}\n","import { BufferResource } from '../../rendering/renderers/shared/buffer/BufferResource';\nimport { UniformGroup } from '../../rendering/renderers/shared/shader/UniformGroup';\nimport { TextureSource } from '../../rendering/renderers/shared/texture/sources/TextureSource';\nimport { TextureStyle } from '../../rendering/renderers/shared/texture/TextureStyle';\n\nimport type { ShaderSyncData, ShaderSyncFunction } from '../../rendering/renderers/gl/shader/GlShaderSystem';\nimport type { WebGLRenderer } from '../../rendering/renderers/gl/WebGLRenderer';\nimport type { Shader } from '../../rendering/renderers/shared/shader/Shader';\n\nexport function generateShaderSyncPolyfill(): ShaderSyncFunction\n{\n    return syncShader;\n}\n\nfunction syncShader(renderer: WebGLRenderer, shader: Shader, syncData: ShaderSyncData): void\n{\n    const gl = renderer.gl;\n    const shaderSystem = renderer.shader;\n    const programData = shaderSystem._getProgramData(shader.glProgram);\n\n    // loop through the groups and sync everything...\n    for (const i in shader.groups)\n    {\n        const bindGroup = shader.groups[i];\n\n        for (const j in bindGroup.resources)\n        {\n            const resource = bindGroup.resources[j];\n\n            if (resource instanceof UniformGroup)\n            {\n                if (resource.ubo)\n                {\n                    shaderSystem.bindUniformBlock(\n                        resource,\n                        shader._uniformBindMap[i as unknown as number][j as unknown as number],\n                        syncData.blockIndex++\n                    );\n                }\n                else\n                {\n                    shaderSystem.updateUniformGroup(resource);\n                }\n            }\n            else if (resource instanceof BufferResource)\n            {\n                shaderSystem.bindUniformBlock(\n                    resource,\n                    shader._uniformBindMap[i as unknown as number][j as unknown as number],\n                    syncData.blockIndex++\n                );\n            }\n            else if (resource instanceof TextureSource)\n            {\n                // TODO really we should not be binding the sampler here too\n                renderer.texture.bind(resource, syncData.textureCount);\n\n                const uniformName = shader._uniformBindMap[i as unknown as number][j as unknown as number];\n\n                const uniformData = programData.uniformData[uniformName];\n\n                if (uniformData)\n                {\n                    if (uniformData.value !== syncData.textureCount)\n                    {\n                        gl.uniform1i(uniformData.location, syncData.textureCount);\n                    }\n\n                    syncData.textureCount++;\n                }\n            }\n            else if (resource instanceof TextureStyle)\n            {\n                // TODO not doing anything here works is assuming that textures are bound with the style they own.\n                // this.renderer.texture.bindSampler(resource, syncData.textureCount);\n            }\n        }\n    }\n}\n","/**\n * This file is auto generated by scripts/utils/autoGenerateUnsafeEvalFunctions.ts\n * Do not edit manually - or you will be sad.\n */\n\nimport type { UNIFORM_TYPES } from '../../rendering/renderers/shared/shader/types';\n\nexport type UboUploadFunction = (name: string, data: Float32Array, offset: number, uv: any, v: any) => void;\nexport const uboParserFunctions: UboUploadFunction[] = [\n    (name: string, data: Float32Array, offset: number, uv: any, _v: any): void =>\n    {\n        const matrix = uv[name].toArray(true);\n\n        data[offset] = matrix[0];\n        data[offset + 1] = matrix[1];\n        data[offset + 2] = matrix[2];\n        data[offset + 4] = matrix[3];\n        data[offset + 5] = matrix[4];\n        data[offset + 6] = matrix[5];\n        data[offset + 8] = matrix[6];\n        data[offset + 9] = matrix[7];\n        data[offset + 10] = matrix[8];\n    },\n    (name: string, data: Float32Array, offset: number, uv: any, v: any): void =>\n    {\n        v = uv[name];\n        data[offset] = v.x;\n        data[offset + 1] = v.y;\n        data[offset + 2] = v.width;\n        data[offset + 3] = v.height;\n    },\n    (name: string, data: Float32Array, offset: number, uv: any, v: any): void =>\n    {\n        v = uv[name];\n        data[offset] = v.x;\n        data[offset + 1] = v.y;\n    },\n    (name: string, data: Float32Array, offset: number, uv: any, v: any): void =>\n    {\n        v = uv[name];\n        data[offset] = v.red;\n        data[offset + 1] = v.green;\n        data[offset + 2] = v.blue;\n        data[offset + 3] = v.alpha;\n    },\n    (name: string, data: Float32Array, offset: number, uv: any, v: any): void =>\n    {\n        v = uv[name];\n        data[offset] = v.red;\n        data[offset + 1] = v.green;\n        data[offset + 2] = v.blue;\n    },\n];\nexport const uboSingleFunctionsWGSL: Record<UNIFORM_TYPES | string, UboUploadFunction> = {\n    f32: (_name: string, data: Float32Array, offset: number, _uv: any, v: any): void =>\n    {\n        data[offset] = v;\n    },\n    i32: (_name: string, data: Float32Array, offset: number, _uv: any, v: any): void =>\n    {\n        data[offset] = v;\n    },\n    'vec2<f32>': (_name: string, data: Float32Array, offset: number, _uv: any, v: any): void =>\n    {\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n    },\n    'vec3<f32>': (_name: string, data: Float32Array, offset: number, _uv: any, v: any): void =>\n    {\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n    },\n    'vec4<f32>': (_name: string, data: Float32Array, offset: number, _uv: any, v: any): void =>\n    {\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];\n    },\n    'mat2x2<f32>': (_name: string, data: Float32Array, offset: number, _uv: any, v: any): void =>\n    {\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];\n    },\n    'mat3x3<f32>': (_name: string, data: Float32Array, offset: number, _uv: any, v: any): void =>\n    {\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    },\n    'mat4x4<f32>': (_name: string, data: Float32Array, offset: number, _uv: any, v: any): void =>\n    {\n        for (let i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    },\n    'mat3x2<f32>': (_name: string, data: Float32Array, offset: number, _uv: any, v: any): void =>\n    {\n        for (let i = 0; i < 6; i++)\n        {\n            data[offset + (((i / 3) | 0) * 4) + (i % 3)] = v[i];\n        }\n    },\n    'mat4x2<f32>': (_name: string, data: Float32Array, offset: number, _uv: any, v: any): void =>\n    {\n        for (let i = 0; i < 8; i++)\n        {\n            data[offset + (((i / 4) | 0) * 4) + (i % 4)] = v[i];\n        }\n    },\n    'mat2x3<f32>': (_name: string, data: Float32Array, offset: number, _uv: any, v: any): void =>\n    {\n        for (let i = 0; i < 6; i++)\n        {\n            data[offset + (((i / 2) | 0) * 4) + (i % 2)] = v[i];\n        }\n    },\n    'mat4x3<f32>': (_name: string, data: Float32Array, offset: number, _uv: any, v: any): void =>\n    {\n        for (let i = 0; i < 12; i++)\n        {\n            data[offset + (((i / 4) | 0) * 4) + (i % 4)] = v[i];\n        }\n    },\n    'mat2x4<f32>': (_name: string, data: Float32Array, offset: number, _uv: any, v: any): void =>\n    {\n        for (let i = 0; i < 8; i++)\n        {\n            data[offset + (((i / 2) | 0) * 4) + (i % 2)] = v[i];\n        }\n    },\n    'mat3x4<f32>': (_name: string, data: Float32Array, offset: number, _uv: any, v: any): void =>\n    {\n        for (let i = 0; i < 12; i++)\n        {\n            data[offset + (((i / 3) | 0) * 4) + (i % 3)] = v[i];\n        }\n    },\n};\nexport const uboSingleFunctionsSTD40: Record<UNIFORM_TYPES | string, UboUploadFunction> = {\n    f32: (_name: string, data: Float32Array, offset: number, _uv: any, v: any): void =>\n    {\n        data[offset] = v;\n    },\n    i32: (_name: string, data: Float32Array, offset: number, _uv: any, v: any): void =>\n    {\n        data[offset] = v;\n    },\n    'vec2<f32>': (_name: string, data: Float32Array, offset: number, _uv: any, v: any): void =>\n    {\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n    },\n    'vec3<f32>': (_name: string, data: Float32Array, offset: number, _uv: any, v: any): void =>\n    {\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n    },\n    'vec4<f32>': (_name: string, data: Float32Array, offset: number, _uv: any, v: any): void =>\n    {\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];\n    },\n    'mat2x2<f32>': (_name: string, data: Float32Array, offset: number, _uv: any, v: any): void =>\n    {\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 4] = v[2];\n        data[offset + 5] = v[3];\n    },\n    'mat3x3<f32>': (_name: string, data: Float32Array, offset: number, _uv: any, v: any): void =>\n    {\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    },\n    'mat4x4<f32>': (_name: string, data: Float32Array, offset: number, _uv: any, v: any): void =>\n    {\n        for (let i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    },\n    'mat3x2<f32>': (_name: string, data: Float32Array, offset: number, _uv: any, v: any): void =>\n    {\n        for (let i = 0; i < 6; i++)\n        {\n            data[offset + (((i / 3) | 0) * 4) + (i % 3)] = v[i];\n        }\n    },\n    'mat4x2<f32>': (_name: string, data: Float32Array, offset: number, _uv: any, v: any): void =>\n    {\n        for (let i = 0; i < 8; i++)\n        {\n            data[offset + (((i / 4) | 0) * 4) + (i % 4)] = v[i];\n        }\n    },\n    'mat2x3<f32>': (_name: string, data: Float32Array, offset: number, _uv: any, v: any): void =>\n    {\n        for (let i = 0; i < 6; i++)\n        {\n            data[offset + (((i / 2) | 0) * 4) + (i % 2)] = v[i];\n        }\n    },\n    'mat4x3<f32>': (_name: string, data: Float32Array, offset: number, _uv: any, v: any): void =>\n    {\n        for (let i = 0; i < 12; i++)\n        {\n            data[offset + (((i / 4) | 0) * 4) + (i % 4)] = v[i];\n        }\n    },\n    'mat2x4<f32>': (_name: string, data: Float32Array, offset: number, _uv: any, v: any): void =>\n    {\n        for (let i = 0; i < 8; i++)\n        {\n            data[offset + (((i / 2) | 0) * 4) + (i % 2)] = v[i];\n        }\n    },\n    'mat3x4<f32>': (_name: string, data: Float32Array, offset: number, _uv: any, v: any): void =>\n    {\n        for (let i = 0; i < 12; i++)\n        {\n            data[offset + (((i / 3) | 0) * 4) + (i % 3)] = v[i];\n        }\n    },\n};\n","import { WGSL_TO_STD40_SIZE } from '../../rendering/renderers/gl/shader/utils/createUboElementsSTD40';\nimport { WGSL_ALIGN_SIZE_DATA } from '../../rendering/renderers/gpu/shader/utils/createUboElementsWGSL';\nimport { uniformParsers } from '../../rendering/renderers/shared/shader/utils/uniformParsers';\nimport { uboParserFunctions, uboSingleFunctionsSTD40, uboSingleFunctionsWGSL } from './uboSyncFunctions';\n\nimport type { UboElement, UniformsSyncCallback } from '../../rendering/renderers/shared/shader/types';\nimport type { UniformGroup } from '../../rendering/renderers/shared/shader/UniformGroup';\nimport type { UboUploadFunction } from './uboSyncFunctions';\n\nexport function generateUboSyncPolyfillSTD40(uboElements: UboElement[]): UniformsSyncCallback\n{\n    return generateUboSyncPolyfill(\n        uboElements,\n        uboSingleFunctionsSTD40,\n        (uboElement: UboElement) =>\n        {\n            const rowSize = Math.max(WGSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);\n            const elementSize = (uboElement.data.value as Array<number>).length / uboElement.data.size;// size / rowSize;\n            const remainder = (4 - (elementSize % 4)) % 4;\n\n            return (_name: string, data: Float32Array, offset: number, _uv: any, v: any) =>\n            {\n                let t = 0;\n\n                for (let i = 0; i < (uboElement.data.size * rowSize); i++)\n                {\n                    for (let j = 0; j < elementSize; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n\n                    offset += remainder;\n                }\n            };\n        }\n\n    );\n}\n\nexport function generateUboSyncPolyfillWGSL(uboElements: UboElement[]): UniformsSyncCallback\n{\n    return generateUboSyncPolyfill(\n        uboElements,\n        uboSingleFunctionsWGSL,\n        (uboElement: UboElement) =>\n        {\n            const { size, align } = WGSL_ALIGN_SIZE_DATA[uboElement.data.type];\n\n            const remainder = (size - align) / 4;\n\n            return (_name: string, data: Float32Array, offset: number, _uv: any, v: any) =>\n            {\n                let t = 0;\n\n                for (let i = 0; i < uboElement.data.size * (size / 4); i++)\n                {\n                    for (let j = 0; j < (size / 4); j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += remainder;\n                }\n            };\n        }\n    );\n}\n\nfunction generateUboSyncPolyfill(\n    uboElements: UboElement[],\n    uboFunctions: Record<string, UboUploadFunction>,\n    arrayUploadFunction: (uboElement: UboElement) => UboUploadFunction\n): UniformsSyncCallback\n{\n    // loop through all the uniforms..\n    const functionMap: Record<string, {offset: number, func: UboUploadFunction}> = {};\n\n    for (const i in uboElements)\n    {\n        const uboElement = uboElements[i];\n        const uniform = uboElement.data;\n\n        let parsed = false;\n\n        functionMap[uniform.name] = {\n            offset: uboElement.offset / 4,\n            func: null\n        };\n\n        for (let j = 0; j < uniformParsers.length; j++)\n        {\n            const parser = uniformParsers[j];\n\n            if (uniform.type === parser.type && parser.test(uniform))\n            {\n                functionMap[uniform.name].func = uboParserFunctions[j];\n\n                parsed = true;\n\n                break;\n            }\n        }\n\n        // if not parsed...\n\n        if (!parsed)\n        {\n            if (uniform.size === 1)\n            {\n                functionMap[uniform.name].func = uboFunctions[uniform.type];\n            }\n            else\n            {\n                functionMap[uniform.name].func = arrayUploadFunction(uboElement);\n            }\n        }\n    }\n\n    return (\n        uniforms: UniformGroup,\n        data: Float32Array,\n        offset: number\n    ) =>\n    {\n        for (const i in functionMap)\n        {\n            functionMap[i].func(i, data, offset + functionMap[i].offset, uniforms, uniforms[i as keyof typeof uniforms]);\n        }\n    };\n}\n","/**\n * This file is auto generated by scripts/utils/autoGenerateUnsafeEvalFunctions.ts\n * Do not edit manually - or you will be sad.\n */\n\nimport type { UNIFORM_TYPES } from '../../rendering/renderers/shared/shader/types';\n\nexport type UniformUploadFunction = (name: string, cu: any, cv: any, v: any, ud: any, uv: any, gl: any) => void;\n\nexport const uniformSingleParserFunctions: Record<UNIFORM_TYPES | string, UniformUploadFunction> = {\n    f32(name: string, cu: any, cv: any, v: any, ud: any, _uv: any, gl: any): void\n    {\n        if (cv !== v)\n        {\n            cu.value = v;\n            gl.uniform1f(ud[name].location, v);\n        }\n    },\n    'vec2<f32>'(name: string, _cu: any, cv: any, v: any, ud: any, _uv: any, gl: any): void\n    {\n        if (cv[0] !== v[0] || cv[1] !== v[1])\n        {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2f(ud[name].location, v[0], v[1]);\n        }\n    },\n    'vec3<f32>'(name: string, _cu: any, cv: any, v: any, ud: any, _uv: any, gl: any): void\n    {\n        if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n        {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3f(ud[name].location, v[0], v[1], v[2]);\n        }\n    },\n    'vec4<f32>'(name: string, _cu: any, cv: any, v: any, ud: any, _uv: any, gl: any): void\n    {\n        if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n        {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4f(ud[name].location, v[0], v[1], v[2], v[3]);\n        }\n    },\n    i32(name: string, cu: any, cv: any, v: any, ud: any, _uv: any, gl: any): void\n    {\n        if (cv !== v)\n        {\n            cu.value = v;\n            gl.uniform1i(ud[name].location, v);\n        }\n    },\n    'vec2<i32>'(name: string, _cu: any, cv: any, v: any, ud: any, _uv: any, gl: any): void\n    {\n        if (cv[0] !== v[0] || cv[1] !== v[1])\n        {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2i(ud[name].location, v[0], v[1]);\n        }\n    },\n    'vec3<i32>'(name: string, _cu: any, cv: any, v: any, ud: any, _uv: any, gl: any): void\n    {\n        if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n        {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3i(ud[name].location, v[0], v[1], v[2]);\n        }\n    },\n    'vec4<i32>'(name: string, _cu: any, cv: any, v: any, ud: any, _uv: any, gl: any): void\n    {\n        if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n        {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4i(ud[name].location, v[0], v[1], v[2], v[3]);\n        }\n    },\n    u32(name: string, cu: any, cv: any, v: any, ud: any, _uv: any, gl: any): void\n    {\n        if (cv !== v)\n        {\n            cu.value = v;\n            gl.uniform1ui(ud[name].location, v);\n        }\n    },\n    'vec2<u32>'(name: string, _cu: any, cv: any, v: any, ud: any, _uv: any, gl: any): void\n    {\n        if (cv[0] !== v[0] || cv[1] !== v[1])\n        {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2ui(ud[name].location, v[0], v[1]);\n        }\n    },\n    'vec3<u32>'(name: string, _cu: any, cv: any, v: any, ud: any, _uv: any, gl: any): void\n    {\n        if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n        {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3ui(ud[name].location, v[0], v[1], v[2]);\n        }\n    },\n    'vec4<u32>'(name: string, _cu: any, cv: any, v: any, ud: any, _uv: any, gl: any): void\n    {\n        if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n        {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4ui(ud[name].location, v[0], v[1], v[2], v[3]);\n        }\n    },\n    bool(name: string, cu: any, cv: any, v: any, ud: any, _uv: any, gl: any): void\n    {\n        if (cv !== v)\n        {\n            cu.value = v;\n            gl.uniform1i(ud[name].location, v);\n        }\n    },\n    'vec2<bool>'(name: string, _cu: any, cv: any, v: any, ud: any, _uv: any, gl: any): void\n    {\n        if (cv[0] !== v[0] || cv[1] !== v[1])\n        {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2i(ud[name].location, v[0], v[1]);\n        }\n    },\n    'vec3<bool>'(name: string, _cu: any, cv: any, v: any, ud: any, _uv: any, gl: any): void\n    {\n        if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n        {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3i(ud[name].location, v[0], v[1], v[2]);\n        }\n    },\n    'vec4<bool>'(name: string, _cu: any, cv: any, v: any, ud: any, _uv: any, gl: any): void\n    {\n        if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n        {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4i(ud[name].location, v[0], v[1], v[2], v[3]);\n        }\n    },\n    'mat2x2<f32>'(name: string, _cu: any, _cv: any, v: any, ud: any, _uv: any, gl: any): void\n    {\n        gl.uniformMatrix2fv(ud[name].location, false, v);\n    },\n    'mat3x3<f32>'(name: string, _cu: any, _cv: any, v: any, ud: any, _uv: any, gl: any): void\n    {\n        gl.uniformMatrix3fv(ud[name].location, false, v);\n    },\n    'mat4x4<f32>'(name: string, _cu: any, _cv: any, v: any, ud: any, _uv: any, gl: any): void\n    {\n        gl.uniformMatrix4fv(ud[name].location, false, v);\n    },\n};\n\nexport const uniformArrayParserFunctions: Record<UNIFORM_TYPES | string, UniformUploadFunction> = {\n    f32(name: string, _cu: any, _cv: any, v: any, ud: any, _uv: any, gl: any): void\n    {\n        gl.uniform1fv(ud[name].location, v);\n    },\n    'vec2<f32>'(name: string, _cu: any, _cv: any, v: any, ud: any, _uv: any, gl: any): void\n    {\n        gl.uniform2fv(ud[name].location, v);\n    },\n    'vec3<f32>'(name: string, _cu: any, _cv: any, v: any, ud: any, _uv: any, gl: any): void\n    {\n        gl.uniform3fv(ud[name].location, v);\n    },\n    'vec4<f32>'(name: string, _cu: any, _cv: any, v: any, ud: any, _uv: any, gl: any): void\n    {\n        gl.uniform4fv(ud[name].location, v);\n    },\n    'mat2x2<f32>'(name: string, _cu: any, _cv: any, v: any, ud: any, _uv: any, gl: any): void\n    {\n        gl.uniformMatrix2fv(ud[name].location, false, v);\n    },\n    'mat3x3<f32>'(name: string, _cu: any, _cv: any, v: any, ud: any, _uv: any, gl: any): void\n    {\n        gl.uniformMatrix3fv(ud[name].location, false, v);\n    },\n    'mat4x4<f32>'(name: string, _cu: any, _cv: any, v: any, ud: any, _uv: any, gl: any): void\n    {\n        gl.uniformMatrix4fv(ud[name].location, false, v);\n    },\n    i32(name: string, _cu: any, _cv: any, v: any, ud: any, _uv: any, gl: any): void\n    {\n        gl.uniform1iv(ud[name].location, v);\n    },\n    'vec2<i32>'(name: string, _cu: any, _cv: any, v: any, ud: any, _uv: any, gl: any): void\n    {\n        gl.uniform2iv(ud[name].location, v);\n    },\n    'vec3<i32>'(name: string, _cu: any, _cv: any, v: any, ud: any, _uv: any, gl: any): void\n    {\n        gl.uniform3iv(ud[name].location, v);\n    },\n    'vec4<i32>'(name: string, _cu: any, _cv: any, v: any, ud: any, _uv: any, gl: any): void\n    {\n        gl.uniform4iv(ud[name].location, v);\n    },\n    u32(name: string, _cu: any, _cv: any, v: any, ud: any, _uv: any, gl: any): void\n    {\n        gl.uniform1iv(ud[name].location, v);\n    },\n    'vec2<u32>'(name: string, _cu: any, _cv: any, v: any, ud: any, _uv: any, gl: any): void\n    {\n        gl.uniform2iv(ud[name].location, v);\n    },\n    'vec3<u32>'(name: string, _cu: any, _cv: any, v: any, ud: any, _uv: any, gl: any): void\n    {\n        gl.uniform3iv(ud[name].location, v);\n    },\n    'vec4<u32>'(name: string, _cu: any, _cv: any, v: any, ud: any, _uv: any, gl: any): void\n    {\n        gl.uniform4iv(ud[name].location, v);\n    },\n    bool(name: string, _cu: any, _cv: any, v: any, ud: any, _uv: any, gl: any): void\n    {\n        gl.uniform1iv(ud[name].location, v);\n    },\n    'vec2<bool>'(name: string, _cu: any, _cv: any, v: any, ud: any, _uv: any, gl: any): void\n    {\n        gl.uniform2iv(ud[name].location, v);\n    },\n    'vec3<bool>'(name: string, _cu: any, _cv: any, v: any, ud: any, _uv: any, gl: any): void\n    {\n        gl.uniform3iv(ud[name].location, v);\n    },\n    'vec4<bool>'(name: string, _cu: any, _cv: any, v: any, ud: any, _uv: any, gl: any): void\n    {\n        gl.uniform4iv(ud[name].location, v);\n    },\n};\n\nexport const uniformParserFunctions: UniformUploadFunction[] = [\n    (name: string, _cu: any, _cv: any, _v: any, ud: any, uv: any, gl: any): void =>\n    {\n        gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));\n    },\n    (name: string, _cu: any, cv: any, v: any, ud: any, uv: any, gl: any): void =>\n    {\n        cv = ud[name].value;\n        v = uv[name];\n        if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n        {\n            cv[0] = v.x;\n            cv[1] = v.y;\n            cv[2] = v.width;\n            cv[3] = v.height;\n            gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);\n        }\n    },\n    (name: string, _cu: any, cv: any, v: any, ud: any, uv: any, gl: any): void =>\n    {\n        cv = ud[name].value;\n        v = uv[name];\n        if (cv[0] !== v.x || cv[1] !== v.y)\n        {\n            cv[0] = v.x;\n            cv[1] = v.y;\n            gl.uniform2f(ud[name].location, v.x, v.y);\n        }\n    },\n    (name: string, _cu: any, cv: any, v: any, ud: any, uv: any, gl: any): void =>\n    {\n        cv = ud[name].value;\n        v = uv[name];\n        if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha)\n        {\n            cv[0] = v.red;\n            cv[1] = v.green;\n            cv[2] = v.blue;\n            cv[3] = v.alpha;\n            gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);\n        }\n    },\n    (name: string, _cu: any, cv: any, v: any, ud: any, uv: any, gl: any): void =>\n    {\n        cv = ud[name].value;\n        v = uv[name];\n        if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue)\n        {\n            cv[0] = v.red;\n            cv[1] = v.green;\n            cv[2] = v.blue;\n            gl.uniform3f(ud[name].location, v.red, v.green, v.blue);\n        }\n    },\n];\n","import { uniformParsers } from '../../rendering/renderers/shared/shader/utils/uniformParsers';\nimport { uniformArrayParserFunctions, uniformParserFunctions, uniformSingleParserFunctions } from './uniformSyncFunctions';\n\nimport type { GlUniformData } from '../../rendering/renderers/gl/shader/GlProgram';\nimport type { WebGLRenderer } from '../../rendering/renderers/gl/WebGLRenderer';\nimport type { UniformsSyncCallback } from '../../rendering/renderers/shared/shader/types';\nimport type { UniformGroup } from '../../rendering/renderers/shared/shader/UniformGroup';\nimport type { UniformUploadFunction } from './uniformSyncFunctions';\n\nexport function generateUniformsSyncPolyfill(\n    group: UniformGroup,\n    uniformData: Record<string, GlUniformData>\n): UniformsSyncCallback\n{\n    // loop through all the uniforms..\n    const functionMap: Record<string, UniformUploadFunction> = {};\n\n    for (const i in group.uniformStructures)\n    {\n        if (!uniformData[i]) continue;\n\n        const uniform = group.uniformStructures[i];\n\n        let parsed = false;\n\n        for (let j = 0; j < uniformParsers.length; j++)\n        {\n            const parser = uniformParsers[j];\n\n            if (uniform.type === parser.type && parser.test(uniform))\n            {\n                functionMap[i] = uniformParserFunctions[j];\n\n                parsed = true;\n\n                break;\n            }\n        }\n\n        // if not parsed...\n\n        if (!parsed)\n        {\n            const templateType = uniform.size === 1 ? uniformSingleParserFunctions : uniformArrayParserFunctions;\n\n            functionMap[i] = templateType[uniform.type];\n        }\n    }\n\n    return (\n        ud: Record<string, any>,\n        uv: Record<string, any>,\n        renderer: WebGLRenderer) =>\n    {\n        const gl = renderer.gl;\n\n        for (const i in functionMap)\n        {\n            const v = uv[i];\n            const cu = ud[i];\n            const cv = ud[i].value;\n\n            functionMap[i](i, cu, cv, v, ud, uv, gl);\n        }\n    };\n}\n","import { GlUboSystem } from '../rendering/renderers/gl/GlUboSystem';\nimport { GlShaderSystem } from '../rendering/renderers/gl/shader/GlShaderSystem';\nimport { GlUniformGroupSystem } from '../rendering/renderers/gl/shader/GlUniformGroupSystem';\nimport { GpuUboSystem } from '../rendering/renderers/gpu/GpuUboSystem';\nimport { UboSystem } from '../rendering/renderers/shared/shader/UboSystem';\nimport { AbstractRenderer } from '../rendering/renderers/shared/system/AbstractRenderer';\nimport { ParticleBuffer } from '../scene/particle-container/shared/ParticleBuffer';\nimport { generateParticleUpdatePolyfill } from './particle/generateParticleUpdatePolyfill';\nimport { generateShaderSyncPolyfill } from './shader/generateShaderSyncPolyfill';\nimport {\n    generateUboSyncPolyfillSTD40,\n    generateUboSyncPolyfillWGSL\n} from './ubo/generateUboSyncPolyfill';\nimport { generateUniformsSyncPolyfill } from './uniforms/generateUniformsSyncPolyfill';\n\nfunction selfInstall()\n{\n    Object.assign(AbstractRenderer.prototype, {\n        // override unsafeEval check, as we don't need to use it\n        _unsafeEvalCheck()\n        {\n            // Do nothing, don't throw error\n        },\n    });\n\n    Object.assign(UboSystem.prototype, {\n        // override unsafeEval check, as we don't need to use it\n        _systemCheck()\n        {\n            // Do nothing, don't throw error\n        },\n    });\n\n    Object.assign(GlUniformGroupSystem.prototype, {\n        // use polyfill which avoids eval method\n        _generateUniformsSync: generateUniformsSyncPolyfill,\n    });\n\n    Object.assign(GlUboSystem.prototype, {\n        // use polyfill which avoids eval method\n        _generateUboSync: generateUboSyncPolyfillSTD40,\n    });\n\n    Object.assign(GpuUboSystem.prototype, {\n        // use polyfill which avoids eval method\n        _generateUboSync: generateUboSyncPolyfillWGSL,\n    });\n\n    Object.assign(GlShaderSystem.prototype, {\n        // use polyfill which avoids eval method\n        _generateShaderSync: generateShaderSyncPolyfill,\n    });\n\n    Object.assign(ParticleBuffer.prototype, {\n\n        // use polyfill which avoids eval method\n        generateParticleUpdate: generateParticleUpdatePolyfill,\n    });\n}\n\nselfInstall();\n"],"names":["ViewableBuffer","sizeOrBuffer","type","createIndicesForQuads","size","outBuffer","totalIndices","i","j","generateParticleUpdateFunction","e","o","t","r","c","n","p","getAttributeInfoFromFormat","a","Geometry","Buffer","BufferUsage","particleUpdateFunctions","ps","f32v","_u32v","offset","stride","w0","w1","h0","h1","texture","sx","sy","ax","ay","trim","orig","x","y","rotation","uvs","_f32v","u32v","UniformGroup","resource","BufferResource","TextureSource","TextureStyle","uboParserFunctions","name","data","uv","_v","matrix","v","uboSingleFunctionsWGSL","_name","_uv","uboSingleFunctionsSTD40","WGSL_TO_STD40_SIZE","uboElement","WGSL_ALIGN_SIZE_DATA","uniformParsers","uniformSingleParserFunctions","cu","cv","ud","gl","_cu","_cv","uniformArrayParserFunctions","uniformParserFunctions","generateUniformsSyncPolyfill","s","m","f","AbstractRenderer","UboSystem","GlUniformGroupSystem","GlUboSystem","GpuUboSystem","GlShaderSystem"],"mappings":";;;;;;oFAMa,MAAAA,CACb,CA+BI,YAAYC,EACZ,CACQ,OAAOA,GAAiB,SAExB,KAAK,cAAgB,IAAI,YAAYA,CAAY,EAE5CA,aAAwB,WAE7B,KAAK,cAAgBA,EAAa,OAIlC,KAAK,cAAgBA,EAGzB,KAAK,WAAa,IAAI,YAAY,KAAK,aAAa,EACpD,KAAK,YAAc,IAAI,aAAa,KAAK,aAAa,EAEtD,KAAK,KAAO,KAAK,cAAc,UACnC,CAGA,IAAI,UACJ,CACI,OAAK,KAAK,YAEN,KAAK,UAAY,IAAI,UAAU,KAAK,aAAa,GAG9C,KAAK,SAChB,CAGA,IAAI,WACJ,CACI,OAAK,KAAK,aAEN,KAAK,WAAa,IAAI,WAAW,KAAK,aAAa,GAGhD,KAAK,UAChB,CAGA,IAAI,WACJ,CACI,OAAK,KAAK,aAEN,KAAK,WAAa,IAAI,WAAW,KAAK,aAAa,GAGhD,KAAK,UAChB,CAGA,IAAI,WACJ,CACI,OAAK,KAAK,aAEN,KAAK,WAAa,IAAI,WAAW,KAAK,aAAa,GAGhD,KAAK,UAChB,CAGA,IAAI,aACJ,CACI,OAAK,KAAK,gBAEN,KAAK,cAAgB,IAAI,aAAa,KAAK,aAAa,GAGrD,KAAK,aAChB,CAGA,IAAI,eACJ,CACI,OAAK,KAAK,kBAEN,KAAK,gBAAkB,IAAI,eAAe,KAAK,aAAa,GAGzD,KAAK,eAChB,CAQO,KAAKC,EACZ,CACI,OAAQ,KAAa,GAAGA,CAAI,MAAM,CACtC,CAGO,SACP,CACI,KAAK,cAAgB,KACrB,KAAK,UAAY,KACjB,KAAK,WAAa,KAClB,KAAK,WAAa,KAClB,KAAK,WAAa,KAClB,KAAK,WAAa,KAClB,KAAK,WAAa,KAClB,KAAK,YAAc,IACvB,CAQA,OAAc,OAAOA,EACrB,CACI,OAAQA,EACR,CACI,IAAK,OACL,IAAK,QACD,MACJ,GAAA,IAAK,QACL,IAAK,SACD,MACJ,GAAA,IAAK,QACL,IAAK,SACL,IAAK,UACD,MAAO,GACX,QACI,MAAM,IAAI,MAAM,GAAGA,CAAI,0BAA0B,CACzD,CACJ,CACJ,CCtKO,SAASC,EACZC,EACAC,EAA8C,KAElD,CAEI,MAAMC,EAAeF,EAAO,EAY5B,GATIE,EAAe,MAEfD,EAAYA,GAAa,IAAI,YAAYC,CAAY,EAIrDD,EAAYA,GAAa,IAAI,YAAYC,CAAY,EAGrDD,EAAU,SAAWC,EAErB,MAAM,IAAI,MAAM,uCAAuCD,EAAU,MAAM,iBAAiBC,CAAY,EAAE,EAI1G,QAASC,EAAI,EAAGC,EAAI,EAAGD,EAAID,EAAcC,GAAK,EAAGC,GAAK,EAElDH,EAAUE,EAAI,CAAC,EAAIC,EAAI,EACvBH,EAAUE,EAAI,CAAC,EAAIC,EAAI,EACvBH,EAAUE,EAAI,CAAC,EAAIC,EAAI,EACvBH,EAAUE,EAAI,CAAC,EAAIC,EAAI,EACvBH,EAAUE,EAAI,CAAC,EAAIC,EAAI,EACvBH,EAAUE,EAAI,CAAC,EAAIC,EAAI,EAG3B,OAAOH,CACX,CChCO,SAAAI,EAAAC,EAAA,CAAA,MAAA,CAAA,cAAAH,EAAAG,EAAA,EAAA,EAAA,aAAAH,EAAAG,EAAA,EAAA,CAAA,CAAA,CAAA,SAAAH,EAAAG,EAAAC,EAAA,CAAA,MAAAC,EAAA,CAAA,EAAAA,EAAA,KAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,aAegB,EAAA,IAAAC,EAAA,EAAA,UAAAC,KAAAJ,EAAA,CAAA,MAAAK,EAAAL,EAAAI,CAAA,EAAA,GAAAH,IAAAI,EAAA,QAAA,SAAAH,EAAA,KAAA,oBAAAC,CAAA,EAAA,EAAAD,EAAA,KAAAG,EAAA,IAAA,EAAA,MAAAC,EAsBOC;;;KAKP,EAAAL,EAAA,QAAA;AAAA,uBAMGC,CAAA;AAAA,KACG,EAAA,MAAAK,EAAAN,EAAA,KAAA;AAAA,CAGiB,EAAA,OAAA,IAAA,SAAA,KAAA,OAAA,OAAAM,CAAA,CAAA,sLCSZD,KAAAA,2BAAAA,EAAAA,MAAAA,EAAAA,EAAAA,QAAAA,GAAAA,EAAAA,OAAAA,GAAAA,EAAAA,MAAAA,CAAAA,KAAAA,eAAAA,EAAAA,EAAAA,KAAAA,cAAAA,EAAAA,EAAAA,KAAAA,sBAAAA,IAAAA,EAAAA,EAAAA,EAAAA,CAAAA,EAAAA,KAAAA,uBAAAA,IAAAA,EAAAA,EAAAA,EAAAA,CAAAA,EAAAA,KAAAA,YAAAA,EAAAA,CAAAA,EAAAA,MAAAA,EAAAA,IAwBLE,KAAAA,SAAAA,IAAAA,EAAAA,EAAAA,EAAAA,EAAAA,KAAAA,cAAAA,IAKIC,YAIdC,CAAAA,KAAAA,IAAAA,aAAAA,CAAAA,EAAAA,MAAAA,yBAAAA,YAAAA,GAAAA,MAAAA,KAAAA,YAAqBA,OAAAA,KAAAA,+CAGND,KAAAA,OAAAA,CAAAA,KAAAA,IAAAA,aAAAA,CAAAA,EAAAA,MAAAA,0BAAAA,YAAAA,GAAAA,MAIfC,iBAAqBA,OAAAA,KAAAA,wDAMNJ,KAAAA,2BAAAA,EAAAA,MAAAA,EAAAA,EAAAA,SAAAA,EAAAA,aAAAA,EAAAA,cAAAA,CAAAA,OAAAA,KAAAA,eAAAA,OAAAA,KAAAA,eAAAA,EAAAA,OAAAA,EAAAA,EAAAA,OAAAA,EAAAA,MAAAA,CAAAA,EAAAA,GAAAA,EAAAA,OAAAA,EAAAA,aAAAA,EAAAA,cAAAA,CAAAA,OAAAA,KAAAA,cAAAA,OAAAA,KAAAA,cAAAA,EAAAA,OAAAA,EAAAA,EAAAA,OAAAA,EAAAA,MAAAA,CAAAA,EAAAA,GAAAA,EAAAA,KAAAA,CAAAA,EAAAA,SAAAA,KAAAA,WAAAA,EAAAA,MAAAA,EAAAA,KAAAA,kBAAAA,CAAAA,EAAAA,KAAAA,eAAAA,EAAAA,cAAAA,KAAAA,cAAAA,EAAAA,aAAAA,KAAAA,SAAAA,CAAAA,CAAAA,kBAAAA,EAAAA,CAAAA,MAAAA,EAAAA,EAAAA,CAAAA,EAAAA,OAAAA,KAAAA,6BAAAA,CAAAA,EAAAA,KAAAA,6BAAAA,CAAAA,GAAAA,KAAAA,6BAAAA,CAAAA,EAAAA,KAAAA,uBAAAA,CAAAA,EAAAA,KAAAA,6BAAAA,CAAAA,EAAAA,CAAAA,uBAAAA,EAAAA,CAAAA,OAAAA,EAAAA,CAAAA,CAAAA,CAAAA,OAAAA,EAAAA,EAAAA,CAAAA,EAAAA,OAAAA,KAAAA,QAAAA,EAAAA,GAAAA,KAAAA,MAAAA,KAAAA,IAAAA,EAAAA,OAAAA,KAAAA,MAAAA,IAAAA,CAAAA,EAAAA,KAAAA,sBAAAA,IAAAA,EAAAA,KAAAA,MAAAA,KAAAA,cAAAA,EAAAA,CAAAA,EAAAA,KAAAA,uBAAAA,IAAAA,EAAAA,KAAAA,MAAAA,KAAAA,eAAAA,EAAAA,CAAAA,EAAAA,KAAAA,YAAAA,EAAAA,KAAAA,KAAAA,EAAAA,KAAAA,SAAAA,YAAAA,gBAAAA,KAAAA,YAAAA,KAAAA,YAAAA,WAAAA,EAAAA,GAAAA,MAAAA,EAAAA,KAAAA,uBAAAA,GAAAA,KAAAA,eAAAA,EAAAA,EAAAA,YAAAA,EAAAA,UAAAA,EAAAA,KAAAA,eAAAA,gBAAAA,KAAAA,uBAAAA,YAAAA,EAAAA,OAAAA,KAAAA,eAAAA,EAAAA,EAAAA,EAAAA,EAAAA,CAAAA,MAAAA,EAAAA,KAAAA,sBAAAA,KAAAA,cAAAA,EAAAA,EAAAA,YAAAA,EAAAA,UAAAA,EAAAA,KAAAA,cAAAA,gBAAAA,EAAAA,YAAAA,EAAAA,OAAAA,KAAAA,cAAAA,EAAAA,EAAAA,CAAAA,CAAAA,CAAAA,SAAAA,CAAAA,KAAAA,cAAAA,UAAAA,KAAAA,eAAAA,QAAAA,EAAAA,KAAAA,SAAAA,QAAAA,CAAAA,CAAAA,CAAAA,SAAAA,EAAAA,EAAAA,CAAAA,MAAAA,EAAAA,CAAAA,EAAAA,UAAAA,KAAAA,EAAAA,CAAAA,MAAAA,EAAAA,EAAAA,CAAAA,EAAAA,EAAAA,KAAAA,EAAAA,EAAAA,KAAAA,EAAAA,QAAAA,IAAAA,GAAAA,CAAAA,CAAAA,OAAAA,EAAAA,KAAAA,GAAAA,CAAAA,CCnHrB,MAAAK,EAA0B,CACnC,QAAS,CAACC,EAAiBC,EAAoBC,EAAoBC,EAAgBC,IACnF,CACI,IAAIC,EAAK,EACLC,EAAK,EACLC,EAAK,EACLC,EAAK,EAET,QAASxB,EAAI,EAAGA,EAAIgB,EAAG,OAAQ,EAAEhB,EACjC,CACI,MAAMS,EAAIO,EAAGhB,CAAC,EACRyB,EAAUhB,EAAE,QACZiB,EAAKjB,EAAE,OACPkB,EAAKlB,EAAE,OACPmB,EAAKnB,EAAE,QACPoB,EAAKpB,EAAE,QAEPqB,EAAOL,EAAQ,KACfM,EAAON,EAAQ,KAEjBK,GAEAR,EAAKQ,EAAK,EAAKF,EAAKG,EAAK,MACzBV,EAAKC,EAAKQ,EAAK,MAEfN,EAAKM,EAAK,EAAKD,EAAKE,EAAK,OACzBR,EAAKC,EAAKM,EAAK,SAIfT,EAAMU,EAAK,OAAU,EAAIH,GACzBN,EAAMS,EAAK,MAAS,CAACH,EAErBL,EAAKQ,EAAK,QAAU,EAAIF,GACxBL,EAAKO,EAAK,OAAS,CAACF,GAGxBZ,EAAKE,CAAM,EAAIG,EAAKI,EACpBT,EAAKE,EAAS,CAAC,EAAIK,EAAKG,EAExBV,EAAKE,EAASC,CAAM,EAAIC,EAAKK,EAC7BT,EAAKE,EAASC,EAAS,CAAC,EAAII,EAAKG,EAEjCV,EAAKE,EAAUC,EAAS,CAAE,EAAIC,EAAKK,EACnCT,EAAKE,EAAUC,EAAS,EAAK,CAAC,EAAIG,EAAKI,EAEvCV,EAAKE,EAAUC,EAAS,CAAE,EAAIE,EAAKI,EACnCT,EAAKE,EAAUC,EAAS,EAAK,CAAC,EAAIG,EAAKI,EAEvCR,GAAUC,EAAS,CACvB,CACJ,EACA,UAAW,CAACJ,EAAiBC,EAAoBC,EAAoBC,EAAgBC,IACrF,CACI,QAASpB,EAAI,EAAGA,EAAIgB,EAAG,OAAQ,EAAEhB,EACjC,CACI,MAAMS,EAAIO,EAAGhB,CAAC,EACRgC,EAAIvB,EAAE,EACNwB,EAAIxB,EAAE,EAEZQ,EAAKE,CAAM,EAAIa,EACff,EAAKE,EAAS,CAAC,EAAIc,EAEnBhB,EAAKE,EAASC,CAAM,EAAIY,EACxBf,EAAKE,EAASC,EAAS,CAAC,EAAIa,EAE5BhB,EAAKE,EAAUC,EAAS,CAAE,EAAIY,EAC9Bf,EAAKE,EAAUC,EAAS,EAAK,CAAC,EAAIa,EAElChB,EAAKE,EAAUC,EAAS,CAAE,EAAIY,EAC9Bf,EAAKE,EAAUC,EAAS,EAAK,CAAC,EAAIa,EAElCd,GAAUC,EAAS,CACvB,CACJ,EACA,UAAW,CAACJ,EAAiBC,EAAoBC,EAAoBC,EAAgBC,IACrF,CACI,QAASpB,EAAI,EAAGA,EAAIgB,EAAG,OAAQ,EAAEhB,EACjC,CACI,MAAMkC,EAAWlB,EAAGhB,CAAC,EAAE,SAEvBiB,EAAKE,CAAM,EAAIe,EACfjB,EAAKE,EAASC,CAAM,EAAIc,EACxBjB,EAAKE,EAAUC,EAAS,CAAE,EAAIc,EAC9BjB,EAAKE,EAAUC,EAAS,CAAE,EAAIc,EAE9Bf,GAAUC,EAAS,CACvB,CACJ,EACA,IAAK,CAACJ,EAAiBC,EAAoBC,EAAoBC,EAAgBC,IAC/E,CACI,QAASpB,EAAI,EAAGA,EAAIgB,EAAG,OAAQ,EAAEhB,EACjC,CACI,MAAMmC,EAAMnB,EAAGhB,CAAC,EAAE,QAAQ,IAE1BiB,EAAKE,CAAM,EAAIgB,EAAI,GACnBlB,EAAKE,EAAS,CAAC,EAAIgB,EAAI,GAEvBlB,EAAKE,EAASC,CAAM,EAAIe,EAAI,GAC5BlB,EAAKE,EAASC,EAAS,CAAC,EAAIe,EAAI,GAEhClB,EAAKE,EAAUC,EAAS,CAAE,EAAIe,EAAI,GAClClB,EAAKE,EAAUC,EAAS,EAAK,CAAC,EAAIe,EAAI,GAEtClB,EAAKE,EAAUC,EAAS,CAAE,EAAIe,EAAI,GAClClB,EAAKE,EAAUC,EAAS,EAAK,CAAC,EAAIe,EAAI,GAEtChB,GAAUC,EAAS,CACvB,CACJ,EACA,OAAQ,CAACJ,EAAiBoB,EAAqBC,EAAmBlB,EAAgBC,IAClF,CACI,QAASpB,EAAI,EAAGA,EAAIgB,EAAG,OAAQ,EAAEhB,EACjC,CACI,MAAMO,EAAIS,EAAGhB,CAAC,EAAE,MAEhBqC,EAAKlB,CAAM,EAAIZ,EACf8B,EAAKlB,EAASC,CAAM,EAAIb,EACxB8B,EAAKlB,EAAUC,EAAS,CAAE,EAAIb,EAC9B8B,EAAKlB,EAAUC,EAAS,CAAE,EAAIb,EAE9BY,GAAUC,EAAS,CACvB,CACJ,CACJ,kMChGgCV,KAAAA,2BAAAA,EAAAA,MAAAA,EAAAA,OAAAA,EAAAA,GAAAA,EAAAA,EAAAA,KAAAA,CAAAA,OAAAA,EAAAA,eAAAA,EAAAA,gBAAAA,EAAAA,EAAAA,aAAAA,CAAAA,CAAAA,CAAAA,CAAAA,MAAAA,CAAAA,EAAAA,EAAAA,IAAAA,CAAAA,IAAAA,EAAAA,EAAAA,QAAAA,EAAAA,EAAAA,EAAAA,EAAAA,OAAAA,IAAAA,CAAAA,MAAAA,EAAAA,EAAAA,CAAAA,EAAAA,EAAAA,eAAAA,EAAAA,EAAAA,EAAAA,EAAAA,CAAAA,EAAAA,GAAAA,EAAAA,MAAAA,CAAAA,CAAAA,kNCDI4B,KAEhBC,aAAAA,EAAAA,IAAAA,EAAAA,iBAAAA,EAAAA,EAAAA,gBAAAA,CAAAA,EAAAA,CAAAA,EAAAA,EAAAA,YAAAA,EAAAA,EAAAA,mBAAAA,CAAAA,UAAAA,aAaqBC,oBAQAC,EAAAA,iBAAAA,EAAAA,EAAAA,gBAAAA,CAAAA,EAAAA,CAAAA,EAAAA,EAAAA,YAAAA,UAAAA,aAAAA,KAAAA,4MAmBAC,KAKjC,YAAA,CAAA,CAAA,CCpEK,MAAAC,EAA0C,CACnD,CAACC,EAAcC,EAAoB1B,EAAgB2B,EAASC,IAC5D,CACI,MAAMC,EAASF,EAAGF,CAAI,EAAE,QAAQ,EAAI,EAEpCC,EAAK1B,CAAM,EAAI6B,EAAO,CAAC,EACvBH,EAAK1B,EAAS,CAAC,EAAI6B,EAAO,CAAC,EAC3BH,EAAK1B,EAAS,CAAC,EAAI6B,EAAO,CAAC,EAC3BH,EAAK1B,EAAS,CAAC,EAAI6B,EAAO,CAAC,EAC3BH,EAAK1B,EAAS,CAAC,EAAI6B,EAAO,CAAC,EAC3BH,EAAK1B,EAAS,CAAC,EAAI6B,EAAO,CAAC,EAC3BH,EAAK1B,EAAS,CAAC,EAAI6B,EAAO,CAAC,EAC3BH,EAAK1B,EAAS,CAAC,EAAI6B,EAAO,CAAC,EAC3BH,EAAK1B,EAAS,EAAE,EAAI6B,EAAO,CAAC,CAChC,EACA,CAACJ,EAAcC,EAAoB1B,EAAgB2B,EAASG,IAC5D,CACIA,EAAIH,EAAGF,CAAI,EACXC,EAAK1B,CAAM,EAAI8B,EAAE,EACjBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,EACrBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,MACrBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,MACzB,EACA,CAACL,EAAcC,EAAoB1B,EAAgB2B,EAASG,IAC5D,CACIA,EAAIH,EAAGF,CAAI,EACXC,EAAK1B,CAAM,EAAI8B,EAAE,EACjBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,CACzB,EACA,CAACL,EAAcC,EAAoB1B,EAAgB2B,EAASG,IAC5D,CACIA,EAAIH,EAAGF,CAAI,EACXC,EAAK1B,CAAM,EAAI8B,EAAE,IACjBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,MACrBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,KACrBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,KACzB,EACA,CAACL,EAAcC,EAAoB1B,EAAgB2B,EAASG,IAC5D,CACIA,EAAIH,EAAGF,CAAI,EACXC,EAAK1B,CAAM,EAAI8B,EAAE,IACjBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,MACrBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,IACzB,CACJ,EACaC,EAA4E,CACrF,IAAK,CAACC,EAAeN,EAAoB1B,EAAgBiC,EAAUH,IACnE,CACIJ,EAAK1B,CAAM,EAAI8B,CACnB,EACA,IAAK,CAACE,EAAeN,EAAoB1B,EAAgBiC,EAAUH,IACnE,CACIJ,EAAK1B,CAAM,EAAI8B,CACnB,EACA,YAAa,CAACE,EAAeN,EAAoB1B,EAAgBiC,EAAUH,IAC3E,CACIJ,EAAK1B,CAAM,EAAI8B,EAAE,CAAC,EAClBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,CAAC,CAC1B,EACA,YAAa,CAACE,EAAeN,EAAoB1B,EAAgBiC,EAAUH,IAC3E,CACIJ,EAAK1B,CAAM,EAAI8B,EAAE,CAAC,EAClBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,CAAC,EACtBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,CAAC,CAC1B,EACA,YAAa,CAACE,EAAeN,EAAoB1B,EAAgBiC,EAAUH,IAC3E,CACIJ,EAAK1B,CAAM,EAAI8B,EAAE,CAAC,EAClBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,CAAC,EACtBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,CAAC,EACtBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,CAAC,CAC1B,EACA,cAAe,CAACE,EAAeN,EAAoB1B,EAAgBiC,EAAUH,IAC7E,CACIJ,EAAK1B,CAAM,EAAI8B,EAAE,CAAC,EAClBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,CAAC,EACtBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,CAAC,EACtBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,CAAC,CAC1B,EACA,cAAe,CAACE,EAAeN,EAAoB1B,EAAgBiC,EAAUH,IAC7E,CACIJ,EAAK1B,CAAM,EAAI8B,EAAE,CAAC,EAClBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,CAAC,EACtBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,CAAC,EACtBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,CAAC,EACtBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,CAAC,EACtBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,CAAC,EACtBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,CAAC,EACtBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,CAAC,EACtBJ,EAAK1B,EAAS,EAAE,EAAI8B,EAAE,CAAC,CAC3B,EACA,cAAe,CAACE,EAAeN,EAAoB1B,EAAgBiC,EAAUH,IAC7E,CACI,QAASjD,EAAI,EAAGA,EAAI,GAAIA,IAEpB6C,EAAK1B,EAASnB,CAAC,EAAIiD,EAAEjD,CAAC,CAE9B,EACA,cAAe,CAACmD,EAAeN,EAAoB1B,EAAgBiC,EAAUH,IAC7E,CACI,QAASjD,EAAI,EAAGA,EAAI,EAAGA,IAEnB6C,EAAK1B,GAAYnB,EAAI,EAAK,GAAK,EAAMA,EAAI,CAAE,EAAIiD,EAAEjD,CAAC,CAE1D,EACA,cAAe,CAACmD,EAAeN,EAAoB1B,EAAgBiC,EAAUH,IAC7E,CACI,QAASjD,EAAI,EAAGA,EAAI,EAAGA,IAEnB6C,EAAK1B,GAAYnB,EAAI,EAAK,GAAK,EAAMA,EAAI,CAAE,EAAIiD,EAAEjD,CAAC,CAE1D,EACA,cAAe,CAACmD,EAAeN,EAAoB1B,EAAgBiC,EAAUH,IAC7E,CACI,QAASjD,EAAI,EAAGA,EAAI,EAAGA,IAEnB6C,EAAK1B,GAAYnB,EAAI,EAAK,GAAK,EAAMA,EAAI,CAAE,EAAIiD,EAAEjD,CAAC,CAE1D,EACA,cAAe,CAACmD,EAAeN,EAAoB1B,EAAgBiC,EAAUH,IAC7E,CACI,QAASjD,EAAI,EAAGA,EAAI,GAAIA,IAEpB6C,EAAK1B,GAAYnB,EAAI,EAAK,GAAK,EAAMA,EAAI,CAAE,EAAIiD,EAAEjD,CAAC,CAE1D,EACA,cAAe,CAACmD,EAAeN,EAAoB1B,EAAgBiC,EAAUH,IAC7E,CACI,QAASjD,EAAI,EAAGA,EAAI,EAAGA,IAEnB6C,EAAK1B,GAAYnB,EAAI,EAAK,GAAK,EAAMA,EAAI,CAAE,EAAIiD,EAAEjD,CAAC,CAE1D,EACA,cAAe,CAACmD,EAAeN,EAAoB1B,EAAgBiC,EAAUH,IAC7E,CACI,QAASjD,EAAI,EAAGA,EAAI,GAAIA,IAEpB6C,EAAK1B,GAAYnB,EAAI,EAAK,GAAK,EAAMA,EAAI,CAAE,EAAIiD,EAAEjD,CAAC,CAE1D,CACJ,EACaqD,EAA6E,CACtF,IAAK,CAACF,EAAeN,EAAoB1B,EAAgBiC,EAAUH,IACnE,CACIJ,EAAK1B,CAAM,EAAI8B,CACnB,EACA,IAAK,CAACE,EAAeN,EAAoB1B,EAAgBiC,EAAUH,IACnE,CACIJ,EAAK1B,CAAM,EAAI8B,CACnB,EACA,YAAa,CAACE,EAAeN,EAAoB1B,EAAgBiC,EAAUH,IAC3E,CACIJ,EAAK1B,CAAM,EAAI8B,EAAE,CAAC,EAClBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,CAAC,CAC1B,EACA,YAAa,CAACE,EAAeN,EAAoB1B,EAAgBiC,EAAUH,IAC3E,CACIJ,EAAK1B,CAAM,EAAI8B,EAAE,CAAC,EAClBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,CAAC,EACtBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,CAAC,CAC1B,EACA,YAAa,CAACE,EAAeN,EAAoB1B,EAAgBiC,EAAUH,IAC3E,CACIJ,EAAK1B,CAAM,EAAI8B,EAAE,CAAC,EAClBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,CAAC,EACtBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,CAAC,EACtBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,CAAC,CAC1B,EACA,cAAe,CAACE,EAAeN,EAAoB1B,EAAgBiC,EAAUH,IAC7E,CACIJ,EAAK1B,CAAM,EAAI8B,EAAE,CAAC,EAClBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,CAAC,EACtBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,CAAC,EACtBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,CAAC,CAC1B,EACA,cAAe,CAACE,EAAeN,EAAoB1B,EAAgBiC,EAAUH,IAC7E,CACIJ,EAAK1B,CAAM,EAAI8B,EAAE,CAAC,EAClBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,CAAC,EACtBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,CAAC,EACtBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,CAAC,EACtBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,CAAC,EACtBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,CAAC,EACtBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,CAAC,EACtBJ,EAAK1B,EAAS,CAAC,EAAI8B,EAAE,CAAC,EACtBJ,EAAK1B,EAAS,EAAE,EAAI8B,EAAE,CAAC,CAC3B,EACA,cAAe,CAACE,EAAeN,EAAoB1B,EAAgBiC,EAAUH,IAC7E,CACI,QAASjD,EAAI,EAAGA,EAAI,GAAIA,IAEpB6C,EAAK1B,EAASnB,CAAC,EAAIiD,EAAEjD,CAAC,CAE9B,EACA,cAAe,CAACmD,EAAeN,EAAoB1B,EAAgBiC,EAAUH,IAC7E,CACI,QAASjD,EAAI,EAAGA,EAAI,EAAGA,IAEnB6C,EAAK1B,GAAYnB,EAAI,EAAK,GAAK,EAAMA,EAAI,CAAE,EAAIiD,EAAEjD,CAAC,CAE1D,EACA,cAAe,CAACmD,EAAeN,EAAoB1B,EAAgBiC,EAAUH,IAC7E,CACI,QAASjD,EAAI,EAAGA,EAAI,EAAGA,IAEnB6C,EAAK1B,GAAYnB,EAAI,EAAK,GAAK,EAAMA,EAAI,CAAE,EAAIiD,EAAEjD,CAAC,CAE1D,EACA,cAAe,CAACmD,EAAeN,EAAoB1B,EAAgBiC,EAAUH,IAC7E,CACI,QAASjD,EAAI,EAAGA,EAAI,EAAGA,IAEnB6C,EAAK1B,GAAYnB,EAAI,EAAK,GAAK,EAAMA,EAAI,CAAE,EAAIiD,EAAEjD,CAAC,CAE1D,EACA,cAAe,CAACmD,EAAeN,EAAoB1B,EAAgBiC,EAAUH,IAC7E,CACI,QAASjD,EAAI,EAAGA,EAAI,GAAIA,IAEpB6C,EAAK1B,GAAYnB,EAAI,EAAK,GAAK,EAAMA,EAAI,CAAE,EAAIiD,EAAEjD,CAAC,CAE1D,EACA,cAAe,CAACmD,EAAeN,EAAoB1B,EAAgBiC,EAAUH,IAC7E,CACI,QAASjD,EAAI,EAAGA,EAAI,EAAGA,IAEnB6C,EAAK1B,GAAYnB,EAAI,EAAK,GAAK,EAAMA,EAAI,CAAE,EAAIiD,EAAEjD,CAAC,CAE1D,EACA,cAAe,CAACmD,EAAeN,EAAoB1B,EAAgBiC,EAAUH,IAC7E,CACI,QAASjD,EAAI,EAAGA,EAAI,GAAIA,IAEpB6C,EAAK1B,GAAYnB,EAAI,EAAK,GAAK,EAAMA,EAAI,CAAE,EAAIiD,EAAEjD,CAAC,CAE1D,CACJ,kDCpOqCsD,KAAmBC,mBAAAA,EAAAA,KAAAA,IAAAA,EAAAA,GAAAA,CAAAA,EAAAA,EAAAA,EAAAA,KAAAA,MAAAA,OAAAA,EAAAA,KAAAA,KAAAA,GAAAA,EAAAA,EAAAA,GAAAA,EAAAA,MAAAA,CAAAA,EAAAA,EAAAA,EAAAA,EAAAA,IAAAA,CAAAA,IAAAA,EAAAA,EAAAA,QAAAA,EAAAA,EAAAA,EAAAA,EAAAA,KAAAA,KAAAA,EAAAA,IAAAA,CAAAA,QAAAA,EAAAA,EAAAA,EAAAA,EAAAA,IAAAA,EAAAA,GAAAA,EAAAA,EAAAA,GAAAA,EAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,SAAAA,EAAAA,EAAAA,CAAAA,OAAAA,EAAAA,EAAAA,EAAAA,GAAAA,CAAAA,KAAAA,CAAAA,KAAAA,EAAAA,MAAAA,CAAAA,EA8BpBC,0BA0CRC,EAAAA,KAAAA,IAAAA,EAAAA,GAAAA,EAAAA,GAAAA,EAAAA,MAAAA,CAAAA,EAAAA,EAAAA,EAAAA,EAAAA,IAAAA,CAAAA,IAAAA,EAAAA,EAAAA,QAAAA,EAAAA,EAAAA,EAAAA,EAAAA,KAAAA,MAAAA,EAAAA,GAAAA,IAAAA,CAAAA,QAAAA,EAAAA,EAAAA,EAAAA,EAAAA,EAAAA,IAAAA,EAAAA,GAAAA,EAAAA,EAAAA,GAAAA,EAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,SAAAA,EAAAA,EAAAA,EAAAA,EAAAA,CAAAA,MAAAA,EAAAA,CAAAA,EAAAA,UAAAA,KAAAA,EAAAA,CAAAA,MAAAA,EAAAA,EAAAA,CAAAA,EAAAA,EAAAA,EAAAA,KAAAA,IAAAA,EAAAA,GAAAA,EAAAA,EAAAA,IAAAA,EAAAA,CAAAA,OAAAA,EAAAA,OAAAA,EAAAA,KAAAA,IAAAA,EAAAA,QAAAA,EAAAA,EAAAA,EAAAA,KAAAA,mCAEDA,yNCjFpB,MAAMC,EAAsF,CAC/F,IAAId,EAAce,EAASC,EAASX,EAAQY,EAAST,EAAUU,EAC/D,CACQF,IAAOX,IAEPU,EAAG,MAAQV,EACXa,EAAG,UAAUD,EAAGjB,CAAI,EAAE,SAAUK,CAAC,EAEzC,EACA,YAAYL,EAAcmB,EAAUH,EAASX,EAAQY,EAAST,EAAUU,EACxE,EACQF,EAAG,CAAC,IAAMX,EAAE,CAAC,GAAKW,EAAG,CAAC,IAAMX,EAAE,CAAC,KAE/BW,EAAG,CAAC,EAAIX,EAAE,CAAC,EACXW,EAAG,CAAC,EAAIX,EAAE,CAAC,EACXa,EAAG,UAAUD,EAAGjB,CAAI,EAAE,SAAUK,EAAE,CAAC,EAAGA,EAAE,CAAC,CAAC,EAElD,EACA,YAAYL,EAAcmB,EAAUH,EAASX,EAAQY,EAAST,EAAUU,EACxE,EACQF,EAAG,CAAC,IAAMX,EAAE,CAAC,GAAKW,EAAG,CAAC,IAAMX,EAAE,CAAC,GAAKW,EAAG,CAAC,IAAMX,EAAE,CAAC,KAEjDW,EAAG,CAAC,EAAIX,EAAE,CAAC,EACXW,EAAG,CAAC,EAAIX,EAAE,CAAC,EACXW,EAAG,CAAC,EAAIX,EAAE,CAAC,EACXa,EAAG,UAAUD,EAAGjB,CAAI,EAAE,SAAUK,EAAE,CAAC,EAAGA,EAAE,CAAC,EAAGA,EAAE,CAAC,CAAC,EAExD,EACA,YAAYL,EAAcmB,EAAUH,EAASX,EAAQY,EAAST,EAAUU,EACxE,EACQF,EAAG,CAAC,IAAMX,EAAE,CAAC,GAAKW,EAAG,CAAC,IAAMX,EAAE,CAAC,GAAKW,EAAG,CAAC,IAAMX,EAAE,CAAC,GAAKW,EAAG,CAAC,IAAMX,EAAE,CAAC,KAEnEW,EAAG,CAAC,EAAIX,EAAE,CAAC,EACXW,EAAG,CAAC,EAAIX,EAAE,CAAC,EACXW,EAAG,CAAC,EAAIX,EAAE,CAAC,EACXW,EAAG,CAAC,EAAIX,EAAE,CAAC,EACXa,EAAG,UAAUD,EAAGjB,CAAI,EAAE,SAAUK,EAAE,CAAC,EAAGA,EAAE,CAAC,EAAGA,EAAE,CAAC,EAAGA,EAAE,CAAC,CAAC,EAE9D,EACA,IAAIL,EAAce,EAASC,EAASX,EAAQY,EAAST,EAAUU,EAC/D,CACQF,IAAOX,IAEPU,EAAG,MAAQV,EACXa,EAAG,UAAUD,EAAGjB,CAAI,EAAE,SAAUK,CAAC,EAEzC,EACA,YAAYL,EAAcmB,EAAUH,EAASX,EAAQY,EAAST,EAAUU,EACxE,EACQF,EAAG,CAAC,IAAMX,EAAE,CAAC,GAAKW,EAAG,CAAC,IAAMX,EAAE,CAAC,KAE/BW,EAAG,CAAC,EAAIX,EAAE,CAAC,EACXW,EAAG,CAAC,EAAIX,EAAE,CAAC,EACXa,EAAG,UAAUD,EAAGjB,CAAI,EAAE,SAAUK,EAAE,CAAC,EAAGA,EAAE,CAAC,CAAC,EAElD,EACA,YAAYL,EAAcmB,EAAUH,EAASX,EAAQY,EAAST,EAAUU,EACxE,EACQF,EAAG,CAAC,IAAMX,EAAE,CAAC,GAAKW,EAAG,CAAC,IAAMX,EAAE,CAAC,GAAKW,EAAG,CAAC,IAAMX,EAAE,CAAC,KAEjDW,EAAG,CAAC,EAAIX,EAAE,CAAC,EACXW,EAAG,CAAC,EAAIX,EAAE,CAAC,EACXW,EAAG,CAAC,EAAIX,EAAE,CAAC,EACXa,EAAG,UAAUD,EAAGjB,CAAI,EAAE,SAAUK,EAAE,CAAC,EAAGA,EAAE,CAAC,EAAGA,EAAE,CAAC,CAAC,EAExD,EACA,YAAYL,EAAcmB,EAAUH,EAASX,EAAQY,EAAST,EAAUU,EACxE,EACQF,EAAG,CAAC,IAAMX,EAAE,CAAC,GAAKW,EAAG,CAAC,IAAMX,EAAE,CAAC,GAAKW,EAAG,CAAC,IAAMX,EAAE,CAAC,GAAKW,EAAG,CAAC,IAAMX,EAAE,CAAC,KAEnEW,EAAG,CAAC,EAAIX,EAAE,CAAC,EACXW,EAAG,CAAC,EAAIX,EAAE,CAAC,EACXW,EAAG,CAAC,EAAIX,EAAE,CAAC,EACXW,EAAG,CAAC,EAAIX,EAAE,CAAC,EACXa,EAAG,UAAUD,EAAGjB,CAAI,EAAE,SAAUK,EAAE,CAAC,EAAGA,EAAE,CAAC,EAAGA,EAAE,CAAC,EAAGA,EAAE,CAAC,CAAC,EAE9D,EACA,IAAIL,EAAce,EAASC,EAASX,EAAQY,EAAST,EAAUU,EAC/D,CACQF,IAAOX,IAEPU,EAAG,MAAQV,EACXa,EAAG,WAAWD,EAAGjB,CAAI,EAAE,SAAUK,CAAC,EAE1C,EACA,YAAYL,EAAcmB,EAAUH,EAASX,EAAQY,EAAST,EAAUU,EACxE,EACQF,EAAG,CAAC,IAAMX,EAAE,CAAC,GAAKW,EAAG,CAAC,IAAMX,EAAE,CAAC,KAE/BW,EAAG,CAAC,EAAIX,EAAE,CAAC,EACXW,EAAG,CAAC,EAAIX,EAAE,CAAC,EACXa,EAAG,WAAWD,EAAGjB,CAAI,EAAE,SAAUK,EAAE,CAAC,EAAGA,EAAE,CAAC,CAAC,EAEnD,EACA,YAAYL,EAAcmB,EAAUH,EAASX,EAAQY,EAAST,EAAUU,EACxE,EACQF,EAAG,CAAC,IAAMX,EAAE,CAAC,GAAKW,EAAG,CAAC,IAAMX,EAAE,CAAC,GAAKW,EAAG,CAAC,IAAMX,EAAE,CAAC,KAEjDW,EAAG,CAAC,EAAIX,EAAE,CAAC,EACXW,EAAG,CAAC,EAAIX,EAAE,CAAC,EACXW,EAAG,CAAC,EAAIX,EAAE,CAAC,EACXa,EAAG,WAAWD,EAAGjB,CAAI,EAAE,SAAUK,EAAE,CAAC,EAAGA,EAAE,CAAC,EAAGA,EAAE,CAAC,CAAC,EAEzD,EACA,YAAYL,EAAcmB,EAAUH,EAASX,EAAQY,EAAST,EAAUU,EACxE,EACQF,EAAG,CAAC,IAAMX,EAAE,CAAC,GAAKW,EAAG,CAAC,IAAMX,EAAE,CAAC,GAAKW,EAAG,CAAC,IAAMX,EAAE,CAAC,GAAKW,EAAG,CAAC,IAAMX,EAAE,CAAC,KAEnEW,EAAG,CAAC,EAAIX,EAAE,CAAC,EACXW,EAAG,CAAC,EAAIX,EAAE,CAAC,EACXW,EAAG,CAAC,EAAIX,EAAE,CAAC,EACXW,EAAG,CAAC,EAAIX,EAAE,CAAC,EACXa,EAAG,WAAWD,EAAGjB,CAAI,EAAE,SAAUK,EAAE,CAAC,EAAGA,EAAE,CAAC,EAAGA,EAAE,CAAC,EAAGA,EAAE,CAAC,CAAC,EAE/D,EACA,KAAKL,EAAce,EAASC,EAASX,EAAQY,EAAST,EAAUU,EAChE,CACQF,IAAOX,IAEPU,EAAG,MAAQV,EACXa,EAAG,UAAUD,EAAGjB,CAAI,EAAE,SAAUK,CAAC,EAEzC,EACA,aAAaL,EAAcmB,EAAUH,EAASX,EAAQY,EAAST,EAAUU,EACzE,EACQF,EAAG,CAAC,IAAMX,EAAE,CAAC,GAAKW,EAAG,CAAC,IAAMX,EAAE,CAAC,KAE/BW,EAAG,CAAC,EAAIX,EAAE,CAAC,EACXW,EAAG,CAAC,EAAIX,EAAE,CAAC,EACXa,EAAG,UAAUD,EAAGjB,CAAI,EAAE,SAAUK,EAAE,CAAC,EAAGA,EAAE,CAAC,CAAC,EAElD,EACA,aAAaL,EAAcmB,EAAUH,EAASX,EAAQY,EAAST,EAAUU,EACzE,EACQF,EAAG,CAAC,IAAMX,EAAE,CAAC,GAAKW,EAAG,CAAC,IAAMX,EAAE,CAAC,GAAKW,EAAG,CAAC,IAAMX,EAAE,CAAC,KAEjDW,EAAG,CAAC,EAAIX,EAAE,CAAC,EACXW,EAAG,CAAC,EAAIX,EAAE,CAAC,EACXW,EAAG,CAAC,EAAIX,EAAE,CAAC,EACXa,EAAG,UAAUD,EAAGjB,CAAI,EAAE,SAAUK,EAAE,CAAC,EAAGA,EAAE,CAAC,EAAGA,EAAE,CAAC,CAAC,EAExD,EACA,aAAaL,EAAcmB,EAAUH,EAASX,EAAQY,EAAST,EAAUU,EACzE,EACQF,EAAG,CAAC,IAAMX,EAAE,CAAC,GAAKW,EAAG,CAAC,IAAMX,EAAE,CAAC,GAAKW,EAAG,CAAC,IAAMX,EAAE,CAAC,GAAKW,EAAG,CAAC,IAAMX,EAAE,CAAC,KAEnEW,EAAG,CAAC,EAAIX,EAAE,CAAC,EACXW,EAAG,CAAC,EAAIX,EAAE,CAAC,EACXW,EAAG,CAAC,EAAIX,EAAE,CAAC,EACXW,EAAG,CAAC,EAAIX,EAAE,CAAC,EACXa,EAAG,UAAUD,EAAGjB,CAAI,EAAE,SAAUK,EAAE,CAAC,EAAGA,EAAE,CAAC,EAAGA,EAAE,CAAC,EAAGA,EAAE,CAAC,CAAC,EAE9D,EACA,cAAcL,EAAcmB,EAAUC,EAAUf,EAAQY,EAAST,EAAUU,EAC3E,CACIA,EAAG,iBAAiBD,EAAGjB,CAAI,EAAE,SAAU,GAAOK,CAAC,CACnD,EACA,cAAcL,EAAcmB,EAAUC,EAAUf,EAAQY,EAAST,EAAUU,EAC3E,CACIA,EAAG,iBAAiBD,EAAGjB,CAAI,EAAE,SAAU,GAAOK,CAAC,CACnD,EACA,cAAcL,EAAcmB,EAAUC,EAAUf,EAAQY,EAAST,EAAUU,EAC3E,CACIA,EAAG,iBAAiBD,EAAGjB,CAAI,EAAE,SAAU,GAAOK,CAAC,CACnD,CACJ,EAEagB,EAAqF,CAC9F,IAAIrB,EAAcmB,EAAUC,EAAUf,EAAQY,EAAST,EAAUU,EACjE,CACIA,EAAG,WAAWD,EAAGjB,CAAI,EAAE,SAAUK,CAAC,CACtC,EACA,YAAYL,EAAcmB,EAAUC,EAAUf,EAAQY,EAAST,EAAUU,EACzE,CACIA,EAAG,WAAWD,EAAGjB,CAAI,EAAE,SAAUK,CAAC,CACtC,EACA,YAAYL,EAAcmB,EAAUC,EAAUf,EAAQY,EAAST,EAAUU,EACzE,CACIA,EAAG,WAAWD,EAAGjB,CAAI,EAAE,SAAUK,CAAC,CACtC,EACA,YAAYL,EAAcmB,EAAUC,EAAUf,EAAQY,EAAST,EAAUU,EACzE,CACIA,EAAG,WAAWD,EAAGjB,CAAI,EAAE,SAAUK,CAAC,CACtC,EACA,cAAcL,EAAcmB,EAAUC,EAAUf,EAAQY,EAAST,EAAUU,EAC3E,CACIA,EAAG,iBAAiBD,EAAGjB,CAAI,EAAE,SAAU,GAAOK,CAAC,CACnD,EACA,cAAcL,EAAcmB,EAAUC,EAAUf,EAAQY,EAAST,EAAUU,EAC3E,CACIA,EAAG,iBAAiBD,EAAGjB,CAAI,EAAE,SAAU,GAAOK,CAAC,CACnD,EACA,cAAcL,EAAcmB,EAAUC,EAAUf,EAAQY,EAAST,EAAUU,EAC3E,CACIA,EAAG,iBAAiBD,EAAGjB,CAAI,EAAE,SAAU,GAAOK,CAAC,CACnD,EACA,IAAIL,EAAcmB,EAAUC,EAAUf,EAAQY,EAAST,EAAUU,EACjE,CACIA,EAAG,WAAWD,EAAGjB,CAAI,EAAE,SAAUK,CAAC,CACtC,EACA,YAAYL,EAAcmB,EAAUC,EAAUf,EAAQY,EAAST,EAAUU,EACzE,CACIA,EAAG,WAAWD,EAAGjB,CAAI,EAAE,SAAUK,CAAC,CACtC,EACA,YAAYL,EAAcmB,EAAUC,EAAUf,EAAQY,EAAST,EAAUU,EACzE,CACIA,EAAG,WAAWD,EAAGjB,CAAI,EAAE,SAAUK,CAAC,CACtC,EACA,YAAYL,EAAcmB,EAAUC,EAAUf,EAAQY,EAAST,EAAUU,EACzE,CACIA,EAAG,WAAWD,EAAGjB,CAAI,EAAE,SAAUK,CAAC,CACtC,EACA,IAAIL,EAAcmB,EAAUC,EAAUf,EAAQY,EAAST,EAAUU,EACjE,CACIA,EAAG,WAAWD,EAAGjB,CAAI,EAAE,SAAUK,CAAC,CACtC,EACA,YAAYL,EAAcmB,EAAUC,EAAUf,EAAQY,EAAST,EAAUU,EACzE,CACIA,EAAG,WAAWD,EAAGjB,CAAI,EAAE,SAAUK,CAAC,CACtC,EACA,YAAYL,EAAcmB,EAAUC,EAAUf,EAAQY,EAAST,EAAUU,EACzE,CACIA,EAAG,WAAWD,EAAGjB,CAAI,EAAE,SAAUK,CAAC,CACtC,EACA,YAAYL,EAAcmB,EAAUC,EAAUf,EAAQY,EAAST,EAAUU,EACzE,CACIA,EAAG,WAAWD,EAAGjB,CAAI,EAAE,SAAUK,CAAC,CACtC,EACA,KAAKL,EAAcmB,EAAUC,EAAUf,EAAQY,EAAST,EAAUU,EAClE,CACIA,EAAG,WAAWD,EAAGjB,CAAI,EAAE,SAAUK,CAAC,CACtC,EACA,aAAaL,EAAcmB,EAAUC,EAAUf,EAAQY,EAAST,EAAUU,EAC1E,CACIA,EAAG,WAAWD,EAAGjB,CAAI,EAAE,SAAUK,CAAC,CACtC,EACA,aAAaL,EAAcmB,EAAUC,EAAUf,EAAQY,EAAST,EAAUU,EAC1E,CACIA,EAAG,WAAWD,EAAGjB,CAAI,EAAE,SAAUK,CAAC,CACtC,EACA,aAAaL,EAAcmB,EAAUC,EAAUf,EAAQY,EAAST,EAAUU,EAC1E,CACIA,EAAG,WAAWD,EAAGjB,CAAI,EAAE,SAAUK,CAAC,CACtC,CACJ,EAEaiB,EAAkD,CAC3D,CAACtB,EAAcmB,EAAUC,EAAUjB,EAASc,EAASf,EAASgB,IAC9D,CACIA,EAAG,iBAAiBD,EAAGjB,CAAI,EAAE,SAAU,GAAOE,EAAGF,CAAI,EAAE,QAAQ,EAAI,CAAC,CACxE,EACA,CAACA,EAAcmB,EAAUH,EAASX,EAAQY,EAASf,EAASgB,IAC5D,CACIF,EAAKC,EAAGjB,CAAI,EAAE,MACdK,EAAIH,EAAGF,CAAI,GACPgB,EAAG,CAAC,IAAMX,EAAE,GAAKW,EAAG,CAAC,IAAMX,EAAE,GAAKW,EAAG,CAAC,IAAMX,EAAE,OAASW,EAAG,CAAC,IAAMX,EAAE,UAEnEW,EAAG,CAAC,EAAIX,EAAE,EACVW,EAAG,CAAC,EAAIX,EAAE,EACVW,EAAG,CAAC,EAAIX,EAAE,MACVW,EAAG,CAAC,EAAIX,EAAE,OACVa,EAAG,UAAUD,EAAGjB,CAAI,EAAE,SAAUK,EAAE,EAAGA,EAAE,EAAGA,EAAE,MAAOA,EAAE,MAAM,EAEnE,EACA,CAACL,EAAcmB,EAAUH,EAASX,EAAQY,EAASf,EAASgB,IAC5D,CACIF,EAAKC,EAAGjB,CAAI,EAAE,MACdK,EAAIH,EAAGF,CAAI,GACPgB,EAAG,CAAC,IAAMX,EAAE,GAAKW,EAAG,CAAC,IAAMX,EAAE,KAE7BW,EAAG,CAAC,EAAIX,EAAE,EACVW,EAAG,CAAC,EAAIX,EAAE,EACVa,EAAG,UAAUD,EAAGjB,CAAI,EAAE,SAAUK,EAAE,EAAGA,EAAE,CAAC,EAEhD,EACA,CAACL,EAAcmB,EAAUH,EAASX,EAAQY,EAASf,EAASgB,IAC5D,CACIF,EAAKC,EAAGjB,CAAI,EAAE,MACdK,EAAIH,EAAGF,CAAI,GACPgB,EAAG,CAAC,IAAMX,EAAE,KAAOW,EAAG,CAAC,IAAMX,EAAE,OAASW,EAAG,CAAC,IAAMX,EAAE,MAAQW,EAAG,CAAC,IAAMX,EAAE,SAExEW,EAAG,CAAC,EAAIX,EAAE,IACVW,EAAG,CAAC,EAAIX,EAAE,MACVW,EAAG,CAAC,EAAIX,EAAE,KACVW,EAAG,CAAC,EAAIX,EAAE,MACVa,EAAG,UAAUD,EAAGjB,CAAI,EAAE,SAAUK,EAAE,IAAKA,EAAE,MAAOA,EAAE,KAAMA,EAAE,KAAK,EAEvE,EACA,CAACL,EAAcmB,EAAUH,EAASX,EAAQY,EAASf,EAASgB,IAC5D,CACIF,EAAKC,EAAGjB,CAAI,EAAE,MACdK,EAAIH,EAAGF,CAAI,GACPgB,EAAG,CAAC,IAAMX,EAAE,KAAOW,EAAG,CAAC,IAAMX,EAAE,OAASW,EAAG,CAAC,IAAMX,EAAE,QAEpDW,EAAG,CAAC,EAAIX,EAAE,IACVW,EAAG,CAAC,EAAIX,EAAE,MACVW,EAAG,CAAC,EAAIX,EAAE,KACVa,EAAG,UAAUD,EAAGjB,CAAI,EAAE,SAAUK,EAAE,IAAKA,EAAE,MAAOA,EAAE,IAAI,EAE9D,CACJ,ECpTA,SAAAkB,EAAAC,EAAAC,EAAA,CAAA,MAAAhE,EAAA,CAAA,EAAA,UAAAC,KAAA8D,EAAA,kBAAA,CAAA,GAAA,CAAAC,EAAA/D,CAAA,EAAA,SAAA,MAAAF,EAAAgE,EAAA,kBAAA9D,CAAA,EAAA,IAAAN,EAAA,GAAA,QAAAG,EAAA,EAAAA,EAwB4BsD,KAAe,eAAA,OAAAtD,IAAA,CAAA,MAAAK,EAEhBiD,KAAAA,eAAAA,CAAAA,EAAAA,GAAAA,EAAAA,OAAAA,EAAAA,MAAAA,EAAAA,KAAAA,CAAAA,EAAAA,CAAAA,EAAAA,CAAAA,EAAAA,EAAAA,CAAAA,EAAAA,EAAAA,GAAAA,KAAAA,CAAAA,CAAAA,GAAAA,CAAAA,EAAAA,CAAAA,MAAAA,EAAAA,EAAAA,OAAAA,EAAAA,EAAAA,EAAAA,EAAAA,CAAAA,EAAAA,EAAAA,EAAAA,IAAAA,CAAAA,CAAAA,CAAAA,MAAAA,CAAAA,EAAAA,EAAAA,IAAAA,CAAAA,MAAAA,EAAAA,EAAAA,GAAAA,UAAAA,KAAAA,EAAAA,CAAAA,MAAAA,EAAAA,EAAAA,CAAAA,EAAAA,EAAAA,EAAAA,CAAAA,EAAAA,EAAAA,EAAAA,CAAAA,EAAAA,MAAAA,EAAAA,CAAAA,EAAAA,EAAAA,EAAAA,EAAAA,EAAAA,EAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CCrB3B,SAAAa,GAAA,CAAA,OAAA,OAWkBC,KAAAA,iBAAAA,UAAAA,CAAAA,kBAAAA,CAAAA,CAAAA,CAAAA,EAAAA,OAAAA,OAQAC,KAAU,UAAA,UAAA,CAAA,cAAA,CAAA,CAAA,CAAA,EAAA,OAAA,OAQVC,KAAAA,qBAAAA,UAAAA,CAAAA,sBAAAA,CAAAA,CAAAA,EAAAA,OAAAA,OAKAC,KAAAA,YAAAA,UAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,EAAAA,OAAAA,OAKAC,KAAAA,aAAAA,UAAAA,CAAAA,iBAAAA,CAAAA,CAAAA,EAAAA,OAAAA,OAKAC,KAAe,eAAA,UAAA,CAAA,oBAAAnE,CAAA,CAAA,EAAA,OAAA,OAAAT,EAAA,UAAA,CAAA,uBAAAW,CAAA,CAAA,CAAA,CAAA,OAAA2D,EAAA"}