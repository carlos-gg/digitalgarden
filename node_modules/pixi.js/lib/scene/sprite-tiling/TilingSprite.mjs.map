{"version":3,"file":"TilingSprite.mjs","sources":["../../../src/scene/sprite-tiling/TilingSprite.ts"],"sourcesContent":["import { Cache } from '../../assets/cache/Cache';\nimport { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { Transform } from '../../utils/misc/Transform';\nimport { ViewContainer } from '../view/ViewContainer';\n\nimport type { Size } from '../../maths/misc/Size';\nimport type { PointData } from '../../maths/point/PointData';\nimport type { Instruction } from '../../rendering/renderers/shared/instructions/Instruction';\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { Bounds } from '../container/bounds/Bounds';\nimport type { ContainerOptions } from '../container/Container';\nimport type { Optional } from '../container/container-mixins/measureMixin';\nimport type { DestroyOptions } from '../container/destroyTypes';\n\n/**\n * Constructor options used for `TilingSprite` instances. Extends {@link scene.TilingSpriteViewOptions}\n * ```js\n * const tilingSprite = new TilingSprite({\n *    texture: Texture.from('assets/image.png'),\n *    width: 100,\n *    height: 100,\n *    tilePosition: { x: 100, y: 100 },\n *    tileScale: { x: 2, y: 2 },\n * });\n * ```\n * @see {@link scene.TilingSprite}\n * @see {@link scene.TilingSpriteViewOptions}\n * @memberof scene\n */\nexport interface TilingSpriteOptions extends ContainerOptions\n{\n    /**\n     * The anchor point of the sprite\n     * @default {x: 0, y: 0}\n     */\n    anchor?: PointData\n    /**\n     * The offset of the image that is being tiled.\n     * @default {x: 0, y: 0}\n     */\n    tilePosition?: PointData\n    /**\n     * Scaling of the image that is being tiled.\n     * @default {x: 1, y: 1}\n     */\n    tileScale?: PointData\n    /**\n     * The rotation of the image that is being tiled.\n     * @default 0\n     */\n    tileRotation?: number\n    /**\n     * The texture to use for the sprite.\n     * @default Texture.WHITE\n     */\n    texture?: Texture\n    /**\n     * The width of the tiling sprite. #\n     * @default 256\n     */\n    width?: number\n    /**\n     * The height of the tiling sprite.\n     * @default 256\n     */\n    height?: number\n    // TODO needs a better name..\n    /**\n     * @todo\n     * @default false\n     */\n    applyAnchorToTexture?: boolean\n    /** Whether or not to round the x/y position. */\n    roundPixels?: boolean;\n}\n\n/**\n * A tiling sprite is a fast way of rendering a tiling image.\n * @example\n * const tilingSprite = new TilingSprite({\n *    texture: Texture.from('assets/image.png'),\n *    width: 100,\n *    height: 100,\n * });\n *\n * tilingSprite.tilePosition.x = 100;\n * tilingSprite.tilePosition.y = 100;\n *\n * app.stage.addChild(tilingSprite);\n * @memberof scene\n * @extends scene.Container\n */\nexport class TilingSprite extends ViewContainer implements View, Instruction\n{\n    /**\n     * Creates a new tiling sprite.\n     * @param source - The source to create the texture from.\n     * @param options - The options for creating the tiling sprite.\n     * @returns A new tiling sprite.\n     */\n    public static from(source: Texture | string, options: TilingSpriteOptions = {})\n    {\n        if (typeof source === 'string')\n        {\n            return new TilingSprite({\n                texture: Cache.get(source),\n                ...options,\n            });\n        }\n\n        return new TilingSprite({\n            texture: source,\n            ...options,\n        });\n    }\n\n    /** default options for the TilingSprite */\n    public static defaultOptions: TilingSpriteOptions = {\n        /** The texture to use for the sprite. */\n        texture: Texture.EMPTY,\n        /** The anchor point of the sprite */\n        anchor: { x: 0, y: 0 },\n        /** The offset of the image that is being tiled. */\n        tilePosition: { x: 0, y: 0 },\n        /** Scaling of the image that is being tiled. */\n        tileScale: { x: 1, y: 1 },\n        /** The rotation of the image that is being tiled. */\n        tileRotation: 0,\n        /** TODO */\n        applyAnchorToTexture: false,\n    };\n\n    public override readonly renderPipeId: string = 'tilingSprite';\n    public readonly batched = true;\n\n    public _anchor: ObservablePoint;\n\n    public _tileTransform: Transform;\n    public _texture: Texture;\n    public _applyAnchorToTexture: boolean;\n\n    private _width: number;\n    private _height: number;\n\n    /**\n     * @param {rendering.Texture | scene.TilingSpriteOptions} options - The options for creating the tiling sprite.\n     */\n    constructor(options?: Texture | TilingSpriteOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(texture: Texture, width: number, height: number);\n    constructor(...args: [(Texture | TilingSpriteOptions)?] | [Texture, number, number])\n    {\n        let options = args[0] || {};\n\n        if (options instanceof Texture)\n        {\n            options = { texture: options };\n        }\n\n        if (args.length > 1)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'use new TilingSprite({ texture, width:100, height:100 }) instead');\n            // #endif\n\n            options.width = args[1];\n            options.height = args[2];\n        }\n\n        options = { ...TilingSprite.defaultOptions, ...options };\n\n        const {\n            texture,\n            anchor,\n            tilePosition,\n            tileScale,\n            tileRotation,\n            width,\n            height,\n            applyAnchorToTexture,\n            roundPixels,\n            ...rest\n        } = options ?? {};\n\n        super({\n\n            label: 'TilingSprite',\n            ...rest\n        });\n\n        this.allowChildren = false;\n\n        this._anchor = new ObservablePoint(\n            {\n                _onUpdate: () =>\n                {\n                    this.onViewUpdate();\n                }\n            },\n        );\n\n        this._applyAnchorToTexture = applyAnchorToTexture;\n\n        this.texture = texture;\n        this._width = width ?? texture.width;\n        this._height = height ?? texture.height;\n\n        this._tileTransform = new Transform({\n            observer: {\n                _onUpdate: () => this.onViewUpdate(),\n            }\n        });\n\n        if (anchor) this.anchor = anchor;\n        this.tilePosition = tilePosition;\n        this.tileScale = tileScale;\n        this.tileRotation = tileRotation;\n\n        this.roundPixels = roundPixels ?? false;\n    }\n\n    /**\n     * Changes frame clamping in corresponding textureMatrix\n     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n     * @default 0.5\n     * @member {number}\n     */\n    get clampMargin()\n    {\n        return this._texture.textureMatrix.clampMargin;\n    }\n\n    set clampMargin(value: number)\n    {\n        this._texture.textureMatrix.clampMargin = value;\n    }\n\n    /**\n     * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n     * and passed to the constructor.\n     *\n     * The default is `(0,0)`, this means the sprite's origin is the top left.\n     *\n     * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n     *\n     * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n     *\n     * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n     * @example\n     * import { TilingSprite } from 'pixi.js';\n     *\n     * const sprite = new TilingSprite({texture: Texture.WHITE});\n     * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n     */\n    get anchor(): ObservablePoint\n    {\n        return this._anchor;\n    }\n\n    set anchor(value: PointData | number)\n    {\n        typeof value === 'number' ? this._anchor.set(value) : this._anchor.copyFrom(value);\n    }\n\n    /** The offset of the image that is being tiled. */\n    get tilePosition(): ObservablePoint\n    {\n        return this._tileTransform.position;\n    }\n\n    set tilePosition(value: PointData)\n    {\n        this._tileTransform.position.copyFrom(value);\n    }\n\n    /** The scaling of the image that is being tiled. */\n    get tileScale(): ObservablePoint\n    {\n        return this._tileTransform.scale;\n    }\n\n    set tileScale(value: PointData | number)\n    {\n        typeof value === 'number' ? this._tileTransform.scale.set(value) : this._tileTransform.scale.copyFrom(value);\n    }\n\n    set tileRotation(value)\n    {\n        this._tileTransform.rotation = value;\n    }\n\n    /** The rotation of the image that is being tiled. */\n    get tileRotation()\n    {\n        return this._tileTransform.rotation;\n    }\n\n    /** The transform of the image that is being tiled. */\n    get tileTransform()\n    {\n        return this._tileTransform;\n    }\n\n    /**\n     * The local bounds of the sprite.\n     * @type {rendering.Bounds}\n     */\n    get bounds()\n    {\n        if (this._boundsDirty)\n        {\n            this._updateBounds();\n            this._boundsDirty = false;\n        }\n\n        return this._bounds;\n    }\n\n    set texture(value: Texture)\n    {\n        value ||= Texture.EMPTY;\n\n        const currentTexture = this._texture;\n\n        if (currentTexture === value) return;\n\n        if (currentTexture && currentTexture.dynamic) currentTexture.off('update', this.onViewUpdate, this);\n        if (value.dynamic) value.on('update', this.onViewUpdate, this);\n\n        this._texture = value;\n\n        this.onViewUpdate();\n    }\n\n    /** The texture that the sprite is using. */\n    get texture()\n    {\n        return this._texture;\n    }\n\n    /** The width of the tiling area. */\n    override set width(value: number)\n    {\n        this._width = value;\n        this.onViewUpdate();\n    }\n\n    override get width()\n    {\n        return this._width;\n    }\n\n    override set height(value: number)\n    {\n        this._height = value;\n        this.onViewUpdate();\n    }\n\n    /** The height of the tiling area. */\n    override get height()\n    {\n        return this._height;\n    }\n\n    /**\n     * Sets the size of the TilingSprite to the specified width and height.\n     * This is faster than setting the width and height separately.\n     * @param value - This can be either a number or a [Size]{@link Size} object.\n     * @param height - The height to set. Defaults to the value of `width` if not provided.\n     */\n    public override setSize(value: number | Optional<Size, 'height'>, height?: number): void\n    {\n        if (typeof value === 'object')\n        {\n            height = value.height ?? value.width;\n            value = value.width;\n        }\n\n        this._width = value;\n        this._height = height ?? value;\n\n        this.onViewUpdate();\n    }\n\n    /**\n     * Retrieves the size of the TilingSprite as a [Size]{@link Size} object.\n     * This is faster than get the width and height separately.\n     * @param out - Optional object to store the size in.\n     * @returns - The size of the TilingSprite.\n     */\n    public override getSize(out?: Size): Size\n    {\n        out ||= {} as Size;\n        out.width = this._width;\n        out.height = this._height;\n\n        return out;\n    }\n\n    protected override _updateBounds()\n    {\n        const bounds = this._bounds;\n\n        const anchor = this._anchor;\n\n        const width = this._width;\n        const height = this._height;\n\n        bounds.maxX = -anchor._x * width;\n        bounds.minX = bounds.maxX + width;\n\n        bounds.maxY = -anchor._y * height;\n        bounds.minY = bounds.maxY + height;\n    }\n\n    /**\n     * Adds the bounds of this object to the bounds object.\n     * @param bounds - The output bounds object.\n     */\n    public addBounds(bounds: Bounds)\n    {\n        const _bounds = this.bounds;\n\n        bounds.addFrame(\n            _bounds.minX,\n            _bounds.minY,\n            _bounds.maxX,\n            _bounds.maxY,\n        );\n    }\n\n    /**\n     * Checks if the object contains the given point.\n     * @param point - The point to check\n     */\n    public override containsPoint(point: PointData)\n    {\n        const width = this._width;\n        const height = this._height;\n        const x1 = -width * this._anchor._x;\n        let y1 = 0;\n\n        if (point.x >= x1 && point.x <= x1 + width)\n        {\n            y1 = -height * this._anchor._y;\n\n            if (point.y >= y1 && point.y <= y1 + height) return true;\n        }\n\n        return false;\n    }\n\n    protected override onViewUpdate()\n    {\n        this._boundsDirty = true;\n        super.onViewUpdate();\n    }\n\n    /**\n     * Destroys this sprite renderable and optionally its texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n     */\n    public override destroy(options: DestroyOptions = false)\n    {\n        super.destroy(options);\n\n        this._anchor = null;\n        this._tileTransform = null;\n        this._bounds = null;\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            this._texture.destroy(destroyTextureSource);\n        }\n\n        this._texture = null;\n    }\n}\n\n"],"names":[],"mappings":"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"}